[["index.html", "Network Visualization Overview 0.1 Description 0.2 Learning goals 0.3 Prerequisites", " Network Visualization Liza Wood 2023-05-07 Overview 0.1 Description Network science approaches are being increasingly used to explore complex interactions and the general connectivity among entities, from friends in a social network to the spread of a disease in a population. Due its complexity, network data is often explored and communicated using data visualizations. In this intermediate R workshop we will cover how to tell useful stories with network data primarily using the statnet suite of packages and the ggraph plotting package that is compatible with much of the ggplot2 framework. In this interactive and hands-on workshop we’ll practice using these packages in R to plot one-mode and two-mode networks. As we introduce functions unique to these packages we will discuss what visualization features best suit different types of network data and research communication goals. Along the way we will cover basic data preparation steps and how to calculate (or assign) key network descriptives including centrality measures, edge attributes, and community clusters for your plots. 0.2 Learning goals After completing this workshop, learners should be able to: Distinguish between igraph and network objects in R Identify the necessary components for visualizing network objects in ggraph Calculate network and node-level descriptives and integrate them into visualizations Select among various visualization strategies for diverse communication goals Create well-designed network figures Identify where to go to learn more 0.3 Prerequisites The target audience for this workshop is intermediate to advanced R users. This workshop will provide only a cursory introduction to network data and therefore is best suited for learners who have some familiarity working with networks and working with ggplot2. While workshop data will rely on social scientific examples (e.g., social connections and co-occurrence networks), the lessons learned relating to network visualizations can be applied to a wide variety of research questions and learners from all domains are welcome. "],["introduction.html", "1 Introduction 1.1 What are network data? 1.2 Storing network data", " 1 Introduction 1.1 What are network data? Networks are relational data, whereby entities across all types of domains (actors, companies, species, topics, etc.) are connected based on one or more types of relationships (friendship, trade, pollination, in-text co-occurrence, etc.) Networks are useful for studying interdependencies because their structure suggest that entities and their connections inter-relate. Network analytical approaches typically evaluate questions these interdependencies from two perspectives. One is that of selection, whereby an actors choose to make connections based on certain characteristics/decision criteria. For example, a bee may choose to pollinate a certain flower based on its size or scent. A second perspective is that of influence, whereby connections are affecting the characteristics/decisions of actors. For example, being friends with someone who smokes may cause the non-smoker to take up smoking. 1.1.1 Features of a network Networks are composed of ‘nodes’, the data points that represent an entity (also called vertex), and ‘edges’, representing the relationship between the nodes. These network structures are represented in Figure 1. Figure 1.1: Components of a network Network ‘mode’: Networks can take several forms with variation in what kinds of connections can occur. One important distinction can be made between one-mode and two-mode networks. One-mode networks assumes that the nodes are all capable of making connections while two-mode networks assume that nodes of one type can only have relationships to nodes of a different type. Using the example of board members and corporations, Jasny (2012)1 explains: ‘Ties between the board members themselves (e.g., friendship ties) would constitute a one-mode network. Ties between companies (e.g., if the first company supplied the second with raw materials) would also be a one-mode network. The two-mode network is formed by ties from the board members, the first mode, to the boards of companies they sit on, the second mode.’ These two-mode networks, also called bipartite networks, assume that connections cannot be made within each mode (e.g. directly between companies’ boards). Figure 1.2: Two types of networks Node attributes: In both one and two mode networks, nodes have attributes. Node attributes are associated data that describe the entity, which can be either endogenous to the network (i.e. a characteristic of the node based on their place in the network) or exogenous (i.e. a characteristic of the node unrelated to their place in the network). Examples of endogenous node attributes are features of the node in relation to the network, such as their degree centrality. Examples of exogenous node attributes could be the gender of an individual, the sector a company works in, the weight or species of a pollinator, or the author of a word’s corpus. Directionality: The ties that connect entities in a network can be directed or undirected. Directed networks assume that there is a ‘sender’ and ‘receiver’ of an edge, and that the difference between these two matter (e.g. transmitting a disease). On the other hand, undirected networks assume that the connection is based on a mutual relationship (e.g. co-authorship). Whether or not edges are directed will alter our understanding of the network structure, since each connection-based statistic will be divided into incoming and outgoing connections. Figure 1.3: Network directionality Edge attributes: Just like with nodes, edges can also have attributes. Edge attributes can be endogenous to the network, such as the ‘weight’ of the tie (multiple connections) and/or exogenous, such as the type of connection. For example, individuals in a network can be connected through different relationships (e.g. classmates, friends), companies can trade information and/or material goods; pollinators can visit or pollinate. Depending on how a researcher wants to analyze a network, these various types of connections can be considered to exist across multiple ‘levels’. 1.1.2 Network statistics Summaries of networks are usually described at two levels: the network-level and the actor-level. We define a few below to standardize some of the terminology used in this workshop. Network-level statistics Size: Number of nodes and/or number of connections Density: Number of edges out of all possible edges Centralization: Propensity for nodes to connect to few or many nodes; closely related to degree distribution Transitivity/clustering coefficient (global): The ratio of the count of triangles and connected triples in the graph (e.g. propensity for ‘triadic closure’ across a whole network) Actor-level Several types of centrality, which is a measure of an actors’ connectedness based on… Degree: The number of connections an actors has Betweeness: The number of shortest paths Eigenvector: The influence based on connections and the propensity of their connections to have connections Transitivity/clustering coefficient (local): The ratio of the count of triangles connected to the vertex and the triples centered on the vertex (e.g. how dense the ‘neighborhood’ of an actor is) 1.2 Storing network data Network data, which record the relationships (edges) between nodes, are typically stored in one of two ways: edge lists or matrices. Edge lists are columns of data, whereby the positioning of two nodes next to one another in a column indicates a connection. In a one-mode undirected network, the position of names in the columns have little meaning (A -&gt; B = B &lt;- A). In a one-mode directed network, however, the columns take on a meaning, where the first column is a list of names from which a connection originated (e.g. ‘from’, also called ‘ego’), and the second column is a list of names to whom the connection is made (e.g. ‘to’, also called ‘alter’). In these cases, A -&gt; B != B -&gt; A. In two-made networks, where nodes of mode 1 can only connect to nodes of mode 2, but not one another, each column will represent a mode and nodes listed in one column cannot be in the other. Table 1.1: One-mode edge list ego alter A B B B C H D E E G F C G H H J I A J F Table 1.1: Two-mode edge list mode1 mode2 A O B K C K D M E L F L G O H N I N J K Matrices are the graph form for storing relational data. Nodes are listed as the rows and columns, and if two nodes are connected, a value is put into the matrix where they intersect. If two nodes do not have a connection, the value at their intersection is zero. The differences we pointed out in edge lists (directed/undirected, one-mode/two-mode) are reflected in the shape and symmetry of the matrix. One-mode undirected networks are square (i.e. the same nodes are represented in both the rows and columns) and symmetrical (i.e. the values across the diagonal are the same). In one-mode directed networks, the matrix is still square but the matrix is asymmetric: because it may be that nodeA -&gt; nodeB, inputting a value of 1 in row 1 and column 2, but if nodeB !-&gt; nodeA, there is a value of 0 in row 2 and column 1. In a two-mode network the matrix is likely rectangular, where mode one nodes are represented in the rows and mode two nodes are represented in the columns. Typically, two mode networks are not directed. Table 1.2: Undirected one-mode adjacency matrix A B C D E F G H I J A 0 1 0 0 0 0 0 0 0 0 B 0 0 1 0 0 0 0 0 0 0 C 0 0 0 0 0 0 0 1 0 0 D 0 0 0 0 1 0 0 0 0 0 E 0 0 0 0 0 0 1 0 0 0 F 0 0 1 0 0 0 0 0 0 0 G 0 0 0 0 0 0 0 1 0 0 H 0 0 0 0 0 0 0 0 0 1 I 1 0 0 0 0 0 0 0 0 0 J 0 0 0 0 0 1 0 0 0 0 Table 1.2: Undirected two-mode adjacency matrix O K M L N A 1 0 0 0 0 B 0 1 0 0 0 C 0 1 0 0 0 D 0 0 1 0 0 E 0 0 0 1 0 F 0 0 0 1 0 G 1 0 0 0 0 H 0 0 0 0 1 I 0 0 0 0 1 J 0 1 0 0 0 Jasny, Lorien. “Baseline Models for Two-Mode Social Network Data.” Policy Studies Journal 40, no. 3 (2012): 458–91. https://doi.org/10.1111/j.1541-0072.2012.00461.x.↩︎ "],["data.html", "2 Data 2.1 Delta Science Tracker 2.2 Data descriptions", " 2 Data 2.1 Delta Science Tracker This workshop uses publicly available data from the Delta Stewardship Council’s (DSC) Delta Science Tracker. This database is a library of Sacramento and San Joaquin Delta-related research over the last 50 years. As the DSC’s website explains: “The Delta Science Tracker is a tool to improve coordination and collaboration of science activities in a way that is valuable to scientists, decision-makers, and managers in the Delta. The Delta Science Tracker allows users to explore and visualize recent research and monitoring efforts through the lenses of science activities, organizations, and people. It is intended to promote communication, create opportunities for collaboration, and enhance transparency for science funding opportunities and decisions.” The data we’re using was downloaded from the DSC’s visualizations page, with the ‘collaborations by’ filter set to organizations. Additional data were obtained through scraping their webpage, which we did with permission from the DSC. Code for scraping their webpage can be found here. Figure 2.1: Miles Hermann 2.2 Data descriptions Before getting started with visualizations, we want to take a look at the data we have available. Typical questions you should be able to answer before getting started are as follows: What types of nodes do we have and how are they related? What node and/or edge attributes are available? Are the network data one or two mode? Directed or undirected? Let’s take a look at what we have. Two-mode edge list: The DSC data was originally compiled as two-mode network data, describing how organizations/researchers are connected to research projects. In these data, our first mode, org_id, is the organization(s) (agencies, universities, etc) that are working on projects in the Delta. And our second mode, project_id, are the Delta science research projects themselves. This two-mode edge list has 680 rows, whereby 138 organizations are connected with one or more of 297 projects. In these data, organizations often take part in more than one project, and projects often have more than one organizations associated with it. We also have edge attributes, which represent the kind of involvement an organization has in the project: contributor or leader. edges_2mode &lt;- read.csv(&#39;https://raw.githubusercontent.com/ucdavisdatalab/workshop_network_viz/main/data/edgelist_twomode.csv&#39;) dim(edges_2mode) ## [1] 680 4 head(edges_2mode) ## org_id project_id contribution leadership ## 1 49590 50122 TRUE FALSE ## 2 49592 49780 TRUE FALSE ## 3 49592 49865 TRUE FALSE ## 4 49594 49860 TRUE FALSE ## 5 49598 50091 TRUE FALSE ## 6 49600 50170 TRUE FALSE Node list for two-mode network: We also have a list of all the nodes (organizations and projects), each of which has different attributes. We have more node attributes for project nodes than we do for organization nodes, so many of the attributes for organizations are empty. For projects, we have funding data, the dates of the project, as well as a series of categorical tags related to what kinds of scientific and management themes the project addresses. A sample of those are displayed below: nodes_2mode &lt;- read.csv(&#39;https://raw.githubusercontent.com/ucdavisdatalab/workshop_network_viz/main/data/nodelist_twomode.csv&#39;) head(nodes_2mode[,c(1,4,6,16,31,39)]) ## id funds startdate sci_Channelizedhabitats sci_Amphibiansandreptiles ## 1 50122 $0 2008 FALSE FALSE ## 2 49780 $0 2020 FALSE FALSE ## 3 49865 $445,921 2019 FALSE FALSE ## 4 49860 $931,104 2019 FALSE FALSE ## 5 50091 $0 NA FALSE FALSE ## 6 50170 $0 NA FALSE FALSE ## mgmt_Governance ## 1 FALSE ## 2 FALSE ## 3 FALSE ## 4 FALSE ## 5 FALSE ## 6 FALSE Note that the scientific and management themes are formatted as logical values for each theme. This is because projects can have more than one theme, and so listing them out would cause our data to be ‘long’ with repeated project observations. With node lists, we want to only have unique observations. If your data are ‘long’ (with repeating observations), widen them out as we did with the scientific and management themes. One-mode edge list: We projected our two-mode network to a one-mode network to take a deeper look at research collaborations. Projection of two-mode data into one-mode is a common practice, though it has its limitations (Jasny 2012). By converting two-mode into one-mode data, we can take a look at what organizations are working together on projects. Looking at the dimensions of our data, we have 475 collaborative ties in the network. We’ve also added in an edge attribute to our collaboration tie based on the years that different actors collaborated together. Reveal below for more on how to project one-mode data from two-mode data. edges_1mode &lt;- read.csv(&#39;https://raw.githubusercontent.com/ucdavisdatalab/workshop_network_viz/main/data/edgelist_onemode_projected.csv&#39;) dim(edges_1mode) ## [1] 475 6 head(edges_1mode) ## from_org_id to_org_id Y1995_2009 Y2010_2024 before_1980 Y1980_1994 ## 1 49590 49709 TRUE FALSE FALSE FALSE ## 2 49592 49708 FALSE TRUE FALSE FALSE ## 3 49592 49741 FALSE TRUE FALSE FALSE ## 4 49592 49609 FALSE TRUE FALSE FALSE ## 5 49708 49741 FALSE TRUE FALSE FALSE ## 6 49609 49708 FALSE TRUE FALSE FALSE Reveal: How to project one-mode networks from two-mode edge list # We got our projected data directly from the DST webpage, but generally, # you can project any bipartite network into a one-mode network using the # following steps: # 1. Create count table where organizations are columns (make your mode of # interest the 2nd/y argument in the table) tbl &lt;- table(edges_2mode[c(2,1)]) # 2. Extract column names -- these are mode 1 names (in our case, orgs) orgids &lt;- colnames(tbl) # 3. Take the cross-product of the table to get a co-occurence matrix comat &lt;- crossprod(tbl) # 4. Assign self-co-occurrences 0 diag(comat) &lt;- 0 # Check: This should be symmetrical isSymmetric(comat) # 5. Make a data frame from the matrix and add ids as the column names comat &lt;- data.frame(comat) colnames(comat) &lt;- orgids #. Check: This should be square dim(comat) # 6. Remove those with no co-occurrence at all comat &lt;- comat[rowSums(comat, na.rm = T) != 0, colSums(comat, na.rm = T) != 0] # 7. Make co-occur data frame into matrix object comat &lt;- as.matrix(comat) # 8. Create a graph so that it can be converted into a weighted edge list g &lt;- igraph::graph_from_adjacency_matrix(comat, weighted = T, mode = &#39;undirected&#39;) el_proj &lt;- igraph::get.data.frame(g) Node list for one-mode network: We reduced our two-mode node list down to only a list of our organization nodes, which is what we project in our one-mode network. For organizations, we have very few attributes, only their id, name, and link to their DST page. nodes_1mode &lt;- read.csv(&#39;https://raw.githubusercontent.com/ucdavisdatalab/workshop_network_viz/main/data/nodelist_onemode.csv&#39;) head(nodes_1mode[1:2]) ## id name ## 1 49590 Agricultural Coalitions: Landowners membership fees ## 2 49592 Anchor QEA ## 3 49593 Audubon Canyon Ranch ## 4 49594 Bachand and Associates ## 5 49598 BTS ## 6 49600 CalFish "],["creating-network-objects-in-r.html", "3 Creating network objects in R 3.1 igraph 3.2 network", " 3 Creating network objects in R Now that we have our edge lists and node lists, we want to create our first network object. We are going to start by making a one-mode network. There are two popular network packages (and consequently, network object types) in R. igraph generates a list object of class “igraph” and network generates an list object of class “network”. We are going to be working primarily with network objects, but I’d like to start by making both because you are likely to run into both of them along the way, and both are compatible with the ggraph package that we will be using. So, let’s read in our two network packages. library(igraph) library(network) 3.1 igraph First, let’s make an igraph object. igraph generally seems to have more documentation/Stack Overflow resources than other network packages, so it might be tempting to start here. We can load in the igraph package and use the graph_from_data_frame() function to create our graph. Note that there are dozens of graph_from... functions. Many of them sound (and are) intuitive. When dealing with edge and node lists, I prefer graph_from_data_frame() over graph_from_edgelist() because the former allows us to include the node list as an argument, whereas the latter does not. For our one-mode networks we want to use the edges_1mode and nodes_1mode objects. g1 &lt;- graph_from_data_frame(edges_1mode, vertices = nodes_1mode, directed = F) We can take a look at a summary of the igraph object below. We see the number of nodes (139) and edges (475) summarized at top and our list of node attributes (followed by (v/[datatype])) and edges attributes (followed by (e/[datatype])). summary(g1) ## IGRAPH 9c14403 UN-- 139 475 -- ## + attr: name (v/c), url (v/c), mode (v/n), Y1995_2009 (e/l), Y2010_2024 ## | (e/l), before_1980 (e/l), Y1980_1994 (e/l) The syntax for manipulating igraphs is demonstrated below. We use the V() and E() functions to call on either vertices or edges of our igraph, respective. hen can use the $ symbol to subset from those elements of the network. # Subset the vertex attribute: the names of the vertices head(V(g1)$name) ## [1] &quot;Agricultural Coalitions: Landowners membership fees&quot; ## [2] &quot;Anchor QEA&quot; ## [3] &quot;Audubon Canyon Ranch&quot; ## [4] &quot;Bachand and Associates&quot; ## [5] &quot;BTS&quot; ## [6] &quot;CalFish&quot; # Subset the edge attribute: a logical value for whether a collaboration # happened between 1995-2009 head(E(g1)$Y1995_2009) ## [1] TRUE FALSE FALSE FALSE FALSE FALSE 3.2 network Personally, I find that the igraph package has more limited statistical functionality than network package (and its associated statnet suite of packes), so I prefer network objects. We initialize a network object with the network function (network really needs to get more creative in its naming approaches). Just like with igraph, for our one-mode network we will use our projected edges and mode one nodes. Note: You’ll often see folks converting igraphs to network objects using the intergraph package. library(intergraph) net1_convert &lt;- asNetwork(g1) This conversion function can be very useful, but be sure to double check your work. Right now, with a relatively simple network (undirected and unweighted) the conversion works fine, but in other cases the default settings may require some attention. Because of this, personally I like to generate network objects directly from my edge and node lists. Within the network package we can use the network function and read in our edge lists (as the x argument), vertices, and specify features of the network such as whether or not it is directed or bipartite. net1 &lt;- network(x = edges_1mode, vertices = nodes_1mode, bipartite = F, directed = F) When we print out a network object we get a different-looking summary, but it generally carries the same information: net1 ## Network attributes: ## vertices = 139 ## directed = FALSE ## hyper = FALSE ## loops = FALSE ## multiple = FALSE ## bipartite = FALSE ## total edges= 475 ## missing edges= 0 ## non-missing edges= 475 ## ## Vertex attribute names: ## mode name url vertex.names ## ## Edge attribute names: ## before_1980 Y1980_1994 Y1995_2009 Y2010_2024 The syntax for manipulating network objects is demonstrated below. First, we can use network’s series of get. functions to index components of the network. For node attributes, you can use get.vertex.attribute: head(get.vertex.attribute(net1, &#39;name&#39;)) ## [1] &quot;Agricultural Coalitions: Landowners membership fees&quot; ## [2] &quot;Anchor QEA&quot; ## [3] &quot;Audubon Canyon Ranch&quot; ## [4] &quot;Bachand and Associates&quot; ## [5] &quot;BTS&quot; ## [6] &quot;CalFish&quot; For edge attributes, you can use get.edge.attribute: head(get.edge.attribute(net1, &#39;before_1980&#39;)) ## [1] FALSE FALSE FALSE FALSE FALSE FALSE You can also use special operators, %v% and %e%, call on either vertices or edges of our network and then name the attribute in quotation marks head(net1 %v% &#39;name&#39;) ## [1] &quot;Agricultural Coalitions: Landowners membership fees&quot; ## [2] &quot;Anchor QEA&quot; ## [3] &quot;Audubon Canyon Ranch&quot; ## [4] &quot;Bachand and Associates&quot; ## [5] &quot;BTS&quot; ## [6] &quot;CalFish&quot; head(net1 %e% &#39;Y1995_2009&#39;) ## [1] TRUE FALSE FALSE FALSE FALSE FALSE 3.2.1 Preparing to work with network For the remainder of this tutorial are going to stick to working with the network package, even though the functions we will use for visualization are compatible with both objects. I propose using network objects because they are compatible with more advanced statistical analysis provided through the statnet suite of packages. Because we will be using exclusively network objects, we want to detach igraph before we continue further. This is because there are several commonly-used network functions in both igraph and sna that mask one another. For instance: sna::degree() igraph::degree() The igraph degree function will work only on igraph objects and sna degree function will work only on network objects. To avoid confusion and masking in R, we are going to detach the igraph package and work only with network objects and compatible packages like sna. detach(&quot;package:igraph&quot;, unload = TRUE) "],["one-mode-visualization.html", "4 One-mode visualization 4.1 Introduction 4.2 Guiding questions 4.3 Getting started with ggraph 4.4 Longitudinal networks 4.5 Supplemental Material: Community detection", " 4 One-mode visualization 4.1 Introduction Before we get started plotting network objects in ggraph, let’s also load in three more packages. The sna package provides us with several functions for calculating network statistics, and dplyr and magrittr are packages from that tidyverse that will help us streamline our plotting. library(sna) library(dplyr) library(magrittr) 4.2 Guiding questions As with any visualization, we need to have an idea of what stories we want to tell / what questions we want to answer. Exploring visualizations without certain goals in mind is hard, and so throughout these plotting exercises we will have guiding questions that can keep us focused on what is important as we navigate the wide array of visualization options. For our one-mode visualization we will focus on the following questions: What organizations are most central to the collaborative research network in the Delta? How have the Delta’s research collaborations changed over time? 4.3 Getting started with ggraph For this workshop we will use the ggraph package (and function) for network visualization, created by Thomas Lin Pedersen, who also happens to make ‘generative’ artwork in R. Figure 1.2: Thomas Lin Pedersen generative art with ggraph ggraph relies on (and is a wrapper around) ggplot2, so it follows the same grammar of graphics approach. Let’s load in the ggraph package. library(ggraph) Just as in ggplot, ggraph has three core components: 1. (network) data 2. aesthetic mappings 3. geometries (in this case edges and nodes) We can combine the ggraph() function with a geometry specific to networks, geom_node_point(), to see the nodes as points. To connect these points, we can use an ‘edge link’ geometry, geom_edge_link(), which uses the network object’s built in x, y, (and xend, and yend) variables for the edge data. ggraph(net1) + geom_node_point() + geom_edge_link() ## Using &quot;stress&quot; as default layout What’s special here is that ggraph uses an algorithm to assign x and y mapping coordinates (more on that in a minute), so we don’t need to specify mapping arguments. You can check it out under the hood by looking at the object of the ggraph function: ggraph_obj &lt;- ggraph(net1) head(ggraph_obj$data) ## x y circular mode na ## 1 30.99909 0.05901063 FALSE 1 FALSE ## 2 35.15462 2.53947293 FALSE 1 FALSE ## 3 27.00000 0.00000000 FALSE 1 FALSE ## 4 33.21982 4.57659359 FALSE 1 FALSE ## 5 0.00000 0.00000000 FALSE 1 FALSE ## 6 1.00000 0.00000000 FALSE 1 FALSE ## name ## 1 Agricultural Coalitions: Landowners membership fees ## 2 Anchor QEA ## 3 Audubon Canyon Ranch ## 4 Bachand and Associates ## 5 BTS ## 6 CalFish ## url .ggraph.orig_index ## 1 https://sciencetracker.deltacouncil.ca.gov/node/49590 1 ## 2 https://sciencetracker.deltacouncil.ca.gov/node/49592 2 ## 3 https://sciencetracker.deltacouncil.ca.gov/node/49593 3 ## 4 https://sciencetracker.deltacouncil.ca.gov/node/49594 4 ## 5 https://sciencetracker.deltacouncil.ca.gov/node/49598 5 ## 6 https://sciencetracker.deltacouncil.ca.gov/node/49600 6 ## .ggraph.index ## 1 1 ## 2 2 ## 3 3 ## 4 4 ## 5 5 ## 6 6 Just as in ggplot, we can use the + symbol to layer on plot features, such as themes. For example, the theme_void() can help us focus in on the network visualization itself. ggraph(net1) + geom_node_point() + geom_edge_link() + theme_void() ## Using &quot;stress&quot; as default layout Note how we are alerted that the node point geometry uses a default layout based on the ‘stress’ algorithm to assign its x and y coordinates for plotting the node points as we see above. So next we’ll talk about layout algorithms. 4.3.1 Layouts Networks are typically laid out based on the algorithm you (or the package default) chooses. Layouts are a choice based on how you would like to present the network. Because networks are depicting actors and relationships in an two-dimensional space (x, y), there is no ‘right’ way to plot actors in space (unless, of course, you have actual spatial data associated with your nodes, in which case you could use a geospatial network mapping (e.g. flight route maps)). For scenarios without geospatial coordinates, network theorists have developed layout algorithms which define rules for calculating the x and y coordinates of the nodes. Many layout algorithms aim to represent networks so that strongly connected nodes are plotted in close proximity to one another, representing a ‘core’ and a ‘periphery’. There is an overview of ggraph‘s different layouts presented in this blog post, and descriptions of some of them in the ggraph vignette and documentation, under the layout_tbl_graph_... functions. The layout is selected with the ’layout’ argument within the ggraph function. Below we present our network with a few different layouts. Note that there is a whole world of plotting networks using different conceptualizations of nodes and edges. These conceptualizations of nodes and edges may be dependent on certain layout algorithms. For example, if working with a ‘tree’ based layout, which creates more of a hierarchical structure like a dendrogram, edges as lines may not be suited. Instead, you can specify different edges (e.g. diagonals). For the sake of this workshop we are sticking to more ‘traditional’ network visualization, so we will only be depicting nodes as points and edges as lines. You can also set a manual layout. Because layouts are just x and y coordinates of points defined by a certain algorithm, you can extract those coordinates using the create_layout() function from ggraph, and fix and/or manipulate those coordinates, if need be. We will deal with this more in the longitudinal networks section. fixed_coord &lt;- create_layout(net1, layout = &#39;fr&#39;) head(fixed_coord[c(1:2,5)]) ## x y name ## 1 11.8346955 -0.2371667 Agricultural Coalitions: Landowners membership fees ## 2 0.9149789 2.1853095 Anchor QEA ## 3 2.7280974 -6.9448531 Audubon Canyon Ranch ## 4 4.2577805 7.6989527 Bachand and Associates ## 5 11.2331515 5.9852258 BTS ## 6 7.0722583 12.0218393 CalFish For our one-mode networks, we are going to use the ‘fr’ layout, which is the Fruchterman and Reingold (force-directed algorithm). This is a choice that helps place higher-degree nodes in the center, and low-degree and isolate nodes on the periphery. ggraph(net1, layout = &#39;fr&#39;) + geom_node_point() + geom_edge_link() + theme_void() 4.3.2 Aesthetics features Now that we’ve chosen a layout, let’s start adding some aesthetic features. This process will look very much like aesthetic mapping in ggplot2: we can assign aesthetics like color, size, shape, etc., and these features can either be directly related to the data (i.e. data features) or more generic plot features. As we build out the basics of the ggraph package, we’re going to focus on our first question: What organizations are most central to the collaborative research network in the Delta? Size by degree: One common approach for network visualization is to size nodes by their degree centrality. While more central nodes are already placed at the center of our layout’s algorithm, it can be helpful to also increase their size to communicate this point by adding a data feature. To size by degree, we will want to create a degree variable as a node attribute using the degree function, and assign that attribute to our network data. net1 %v% &#39;degree&#39; &lt;- degree(net1) Hint: if you get Error in degree(net1) : Not a graph object, double check that you have detached the igraph package! Color-blind friendly colors: We’d also like our nodes and edges to be colored differently than the default black, so we can set these colors to our geometries as a plot feature. Because the focus of these networks are on nodes, not edges, we can set our edges to a less pronounced color like grey, and select an accessible, color-blind friendly color palette to select a node color from. I personally like to use viridis: viridis::viridis(12) ## [1] &quot;#440154FF&quot; &quot;#482173FF&quot; &quot;#433E85FF&quot; &quot;#38598CFF&quot; &quot;#2D708EFF&quot; &quot;#25858EFF&quot; ## [7] &quot;#1E9B8AFF&quot; &quot;#2BB07FFF&quot; &quot;#51C56AFF&quot; &quot;#85D54AFF&quot; &quot;#C2DF23FF&quot; &quot;#FDE725FF&quot; The latest version of R studio lets us see these colors when we write them out in a script, so let’s do that, and assign these colors to an object named clrs. We will be referencing this vector as we start using the palette. clrs &lt;- c(&quot;#440154FF&quot;, &quot;#482173FF&quot;, &quot;#433E85FF&quot;, &quot;#38598CFF&quot;, &quot;#2D708EFF&quot;, &quot;#25858EFF&quot;, &quot;#1E9B8AFF&quot;, &quot;#2BB07FFF&quot;, &quot;#51C56AFF&quot;, &quot;#85D54AFF&quot;, &quot;#C2DF23FF&quot;, &quot;#FDE725FF&quot;) We can now integrate these three features: node size, which is stored in our network data, as well as edge color and node color, which will be set without reference to the data. ggraph(net1, layout = &#39;fr&#39;) + geom_node_point(aes(size = degree), color = clrs[4]) + geom_edge_link(color = &quot;gray80&quot;) + theme_void() Notice how layer order matters (as as with ggplot2), and so by having edges layered on top of nodes, we are really hiding the nodes. Let’s try to switch this, but also include some alpha arguments to help increase transparency. ggraph(net1, layout = &#39;fr&#39;) + geom_edge_link(color = &quot;gray80&quot;) + geom_node_point(aes(size = degree), color = clrs[4], alpha = .7) + theme_void() We can also make thematic alterations such as adding a title label to the plot and removing the legend. ggraph(net1, layout = &#39;fr&#39;) + geom_edge_link(color = &quot;gray80&quot;) + geom_node_point(aes(size = degree), color = clrs[4], alpha = .7) + theme_void() + labs(title = &quot;Delta Science Collaborative Research Network&quot;) + theme(legend.position = &quot;none&quot;) Notice that with the ‘fr’ layout (and any other layout algorithm), the coordinates change a bit every time. This is because each time we create a visualization the algorithm is re-run, and there is variation in the exact calculation. You can set your seed (every time before you plot) to keep it consistent. 4.3.3 Node labels So far we are getting a clear shape of the network. But related to our first question we want to understand who is central to collaboration. To better identify our nodes, let’s try to add some node text with the geom_node_text() geometry. Already, we have a variable that is the name of our vertices: head(net1 %v% &#39;name&#39;) ## [1] &quot;Agricultural Coalitions: Landowners membership fees&quot; ## [2] &quot;Anchor QEA&quot; ## [3] &quot;Audubon Canyon Ranch&quot; ## [4] &quot;Bachand and Associates&quot; ## [5] &quot;BTS&quot; ## [6] &quot;CalFish&quot; Let’s add this as a text geometry. ggraph(net1, layout = &#39;fr&#39;) + geom_edge_link(color = &quot;gray80&quot;) + geom_node_point(aes(size = degree), color = clrs[4], alpha = .7) + theme_void() + theme(legend.position = &quot;none&quot;) + labs(title = &quot;Delta Science Collaborative Research Network&quot;) + geom_node_text(aes(label = name), size = 3, color=&quot;black&quot;) Okay, a bit overwhelming. Instead, let’s be selective based on degree. Let’s say we want to take the top 5-degree nodes and label them. # Extract the network&#39;s degree values based on the order of degrees degs &lt;- (net1 %v% &#39;degree&#39;)[order(net1 %v% &#39;degree&#39;, decreasing = T)] # Then identify the top 5 unique degree values topdegs &lt;- unique(degs)[1:5] # Then create a network variable named labels and add the name only if a # node has the number of degrees in the &#39;top degrees&#39; net1 %v% &#39;labels&#39; &lt;- ifelse((net1 %v% &#39;degree&#39;) %in% topdegs, net1 %v% &#39;name&#39;, NA) Now we have a sparse label attribute. net1 %v% &#39;labels&#39; ## [1] NA NA NA NA NA NA NA &quot;CDFW&quot; NA ## [10] NA NA NA NA NA &quot;DWR&quot; NA NA NA ## [19] NA NA NA NA NA NA NA NA NA ## [28] NA NA NA NA NA NA NA NA NA ## [37] NA NA NA NA NA NA NA NA NA ## [46] NA NA NA NA NA NA NA NA NA ## [55] NA NA NA NA NA NA NA NA NA ## [64] NA NA NA NA NA NA NA NA NA ## [73] NA NA NA NA NA NA NA NA NA ## [82] NA &quot;SFEI&quot; NA NA NA NA NA NA NA ## [91] NA NA NA NA NA NA NA NA NA ## [100] NA NA &quot;USBR&quot; NA NA NA NA NA NA ## [109] NA NA &quot;USFWS&quot; NA &quot;USGS&quot; NA NA NA NA ## [118] NA NA NA NA NA NA NA NA NA ## [127] NA NA NA NA NA NA NA NA NA ## [136] NA NA NA NA We can use this labels attribute to make our figure more easily readable. ggraph(net1, layout = &#39;fr&#39;) + geom_edge_link(color = &quot;gray80&quot;) + geom_node_point(aes(size = degree), color = clrs[4], alpha = .7) + theme_void() + theme(legend.position = &quot;none&quot;) + labs(title = &quot;Delta Science Collaborative Research Network&quot;) + geom_node_text(aes(label = labels), size = 3) Almost. Let’s include a repel = T argument to make sure the text doesn’t overlap. ggraph(net1, layout = &#39;fr&#39;) + geom_edge_link(color = &quot;gray80&quot;) + geom_node_point(aes(size = degree), color = clrs[4], alpha = .7) + theme_void() + theme(legend.position = &quot;none&quot;) + labs(title = &quot;Delta Science Collaborative Research Network&quot;) + geom_node_text(aes(label = labels), size = 3, repel = T) So, what organizations are most central to the collaborative research network in the Delta? This network shows us the overall structure of collaboration, and we can use summary statistics to fill in the gaps. At the center of the network are three federal agencies, the US Geological Survey (USGS), US Fish and Wildlife Service (USFWS), and US Bureau of Reclamation (USBR), two state agencies, California Department of Fish and Wildlife (CDFW) and California Department of Water Resources (DWR) one research institute, the San Francisco Estuary Institute (SFEI). Among the 139 organizations involved in scientific research in the Delta, there is a mean degree of 14, suggesting that organizations are involved with, on average, 14 other organizations (across one or more projects). The network is quite connected, as the main component includes 107 (77%) of the organizations, with 27 isolates, meaning that 27 organizations have not collaborated at all. Within that main component, the average path length is 2.3, meaning that on average an organization is less then 3 connections away from any other organization. Bonus code: How to calculate network-level statistics with the sna package network.size(net1) ## [1] 139 mean(net1 %v% &#39;degree&#39;) ## [1] 13.66906 sum(component.largest(net1)) ## [1] 107 length(isolates(net1)) ## [1] 27 main_comp &lt;- component.largest(net1, result = &#39;graph&#39;) mean(geodist(main_comp)[[&#39;gdist&#39;]], na.rm = T) ## [1] 2.345008 4.3.4 Network plotting function Now that we’ve got that down as a base, I want to define this network visualization approach as a function so that we can move through other material a little more smoothly. Feel free to just copy this function – all we are doing is taking the code we previously wrote, and replacing the network name that we’ve been using, net1, with the generic argument for the network name, ‘netname’. netplot_function &lt;- function(netname){ p &lt;- ggraph(netname, layout = &#39;fr&#39;) + geom_edge_link(color = &quot;gray80&quot;) + geom_node_point(aes(size = degree), color = clrs[4], alpha = .7) + theme_void() + theme(legend.position = &quot;none&quot;) + labs(title = &quot;Delta Science Collaborative Research Network&quot;) + geom_node_text(aes(label = labels), size = 3, repel = T) return(p) } 4.3.5 Removing isolates Before we move too far along in our formatting of this figure, we may want to remove isolates. There are certainly occasions where we want to see isolates in our network, but other times we are interested in the main component. We can identify our isolates with the isolates function and then induce our subgraph with only the non-isolate nodes using the get.inducedSubgraph() function. The isolates function identified the numeric id of the node in a network, not associated with a particular network attribute. isolates(net1) ## [1] 5 6 10 14 16 18 26 33 37 42 46 50 56 58 69 76 77 79 97 ## [20] 106 108 115 117 127 131 134 137 As a result, we want to identify the ids of the network that are not isolates, which we can do by indexing the ids from the size of the network. noiso &lt;- (1:network.size(net1))[-isolates(net1)] noiso ## [1] 1 2 3 4 7 8 9 11 12 13 15 17 19 20 21 22 23 24 ## [19] 25 27 28 29 30 31 32 34 35 36 38 39 40 41 43 44 45 47 ## [37] 48 49 51 52 53 54 55 57 59 60 61 62 63 64 65 66 67 68 ## [55] 70 71 72 73 74 75 78 80 81 82 83 84 85 86 87 88 89 90 ## [73] 91 92 93 94 95 96 98 99 100 101 102 103 104 105 107 109 110 111 ## [91] 112 113 114 116 118 119 120 121 122 123 124 125 126 128 129 130 132 133 ## [109] 135 136 138 139 Then we use those to induce the subgraph with only certain vertices. net1_noiso &lt;- get.inducedSubgraph(net1, v = noiso) Now we can see our network without isolates, and quickly use our new netplot_function: netplot_function(net1_noiso) 4.4 Longitudinal networks Lets now turn to think more deeply about edges with the second guiding question: How have the Delta’s research collaborations changed over time? So far we’ve been looking at all of the research collaborations in the DST database, which range from 1950 to more or less present day. But remember that our data have edge attributes based on when the collaborative project occurred, binned into 4 time periods: Before 1980, 1980-1994, 1995-2009, and 2010-2024 (including ongoing projects). net1 ## Network attributes: ## vertices = 139 ## directed = FALSE ## hyper = FALSE ## loops = FALSE ## multiple = FALSE ## bipartite = FALSE ## total edges= 475 ## missing edges= 0 ## non-missing edges= 475 ## ## Vertex attribute names: ## degree labels mode name url vertex.names ## ## Edge attribute names: ## before_1980 Y1980_1994 Y1995_2009 Y2010_2024 4.4.1 Faceting edges One way to visualize subgraphs based on certain edge or node attributes is to use the facet_edges or facet_nodes functions in ggraph. Just like in ggplot, faceting can add another dimension to the data by breaking it out using certain categorical variables. netplot_function(net1_noiso) + facet_edges(~before_1980) This might be an worthwhile approach with different data and visualization goals, but with these data there are two drawbacks: First and generally, faceting does not customize aesthetics such as degree size or label for each subgraph. It keeps the same degree size and assigned labels identified for the complete network, which misrepresents the connections in each subgraph. Second for our data, we have ‘wide’ edge attributes, where each relationship in our data can occur across multiple time periods. That means given our current data structure, we can’t represent the collaborative relationships across time using faceting. One strategy to address this would be to restructure our edge list and create a new network. We aren’t going to go down this road but if you’re interested there is some bonus code below. Instead, we’re going to take a second strategy which is to manually induce each subgraph in order to better customize the plots. Bonus code: How to lengthen the edge list to create a weighted network and facet using a single edge attribute # lengthen the edge list edges_1mode_long &lt;- tidyr::pivot_longer(edges_1mode, Y1995_2009:Y1980_1994, names_to = &quot;timeframe&quot;, values_to = &quot;logical&quot;) %&gt;% dplyr::filter(logical == T) %&gt;% dplyr::select(-logical) # Now we create a network but with the long edges, but because the lengthening # process means we have multiple edges per pair, we need to set multiple = T net1_long &lt;- network(x = edges_1mode_long, vertices = nodes_1mode, bipartite = F, directed = F, multiple = T) # Now we can facet by our single time column, time frame; we&#39;ll remove the # aesthetics that don&#39; carry over ggraph(net1_long, layout = &#39;fr&#39;) + geom_edge_link(color = &quot;gray80&quot;) + geom_node_point(color = clrs[4], alpha = .7) + theme_void() + facet_edges(~timeframe) 4.4.2 Inducing subgraphs by edge attribute To visualize how our networks change over time we are going to be ‘inducing subgraphs’, which is a network phrase for taking slices of our network. Networks can be induced based on certain nodes, which we just did in order to remove isolates. But for this question we will be making subgraphs based on edge attributes. To induce our network based on edge attributes, we’ll want to identify which edges have those attributes. We can identify the edge ids for which each time category is equal to TRUE. We have these are four binary variables, rather than one attribute with four time categories, because organizations can collaborate on projects in more than one time period. # First, let&#39;s give these ids, which will become important later net1 %v% &#39;id&#39; &lt;- net1 %v% &#39;vertex.names&#39; # Get the edges for each time period t1 &lt;- which(net1 %e% &#39;before_1980&#39; == T) t2 &lt;- which(net1 %e% &#39;Y1980_1994&#39; == T) t3 &lt;- which(net1 %e% &#39;Y1995_2009&#39; == T) t4 &lt;- which(net1 %e% &#39;Y2010_2024&#39; == T) # These are the ids of their location in the network. For example: t1 ## [1] 7 21 26 27 43 44 45 48 53 54 55 56 57 58 59 60 61 62 ## [19] 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 ## [37] 81 82 83 84 85 86 87 88 89 90 91 92 93 94 96 101 102 103 ## [55] 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 ## [73] 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 ## [91] 141 155 156 157 158 159 160 161 162 168 169 170 171 172 173 174 175 176 ## [109] 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 ## [127] 195 196 197 198 199 200 201 202 203 204 231 232 233 234 255 258 259 260 ## [145] 261 262 267 268 269 270 271 290 353 354 355 356 357 358 359 360 361 362 ## [163] 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 ## [181] 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 ## [199] 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 ## [217] 417 418 419 437 Now that we have our edge ids for each time period (t1 through t4), we can use the get.inducedSubgraph function and identify the edge ids that we’d like to keep in each network. # Induce subgraphs based on edges net1_t1 &lt;- get.inducedSubgraph(net1, eid = t1) net1_t2 &lt;- get.inducedSubgraph(net1, eid = t2) net1_t3 &lt;- get.inducedSubgraph(net1, eid = t3) net1_t4 &lt;- get.inducedSubgraph(net1, eid = t4) Now we have a slice of the network for each time period. Note that because we did not specify the vertex ids, these networks will include only the nodes that has connections for that time period, and it will not include isolates. For example, though our whole collaborative network has 139 nodes, the network from time period 2 has only 30. net1_t2 ## Network attributes: ## vertices = 30 ## directed = FALSE ## hyper = FALSE ## loops = FALSE ## multiple = FALSE ## bipartite = FALSE ## total edges= 98 ## missing edges= 0 ## non-missing edges= 98 ## ## Vertex attribute names: ## degree id labels mode name url vertex.names ## ## Edge attribute names: ## before_1980 Y1980_1994 Y1995_2009 Y2010_2024 With these induced networks, an important thing to notice is that the attributes assigned in the complete network remain. This is is less important for exogenous, fixed attributes like name, but is important for endogenous/structural attributes like degree. For example, we can check the degree of SFEI in two different networks against the whole network and see that the degree attribute has carried over, but that calculation is no longer correct in the induced networks. (net1 %v% &#39;degree&#39;)[(net1 %v% &#39;name&#39; == &quot;SFEI&quot;)] ## [1] 60 (net1_t1 %v% &#39;degree&#39;)[(net1_t1 %v% &#39;name&#39; == &quot;SFEI&quot;)] ## [1] 60 (net1_t2 %v% &#39;degree&#39;)[(net1_t2 %v% &#39;name&#39; == &quot;SFEI&quot;)] ## [1] 60 We need to update/reassign any structural values that we calculated for the whole network so that they are accurate for each sub-network. net1_t1 %v% &#39;degree&#39; &lt;- degree(net1_t1) net1_t2 %v% &#39;degree&#39; &lt;- degree(net1_t2) net1_t3 %v% &#39;degree&#39; &lt;- degree(net1_t3) net1_t4 %v% &#39;degree&#39; &lt;- degree(net1_t4) Just as the degree attribute needed changed, we also need to change the the label attribute, which was assigned based on degree. We can write a function to do that to avoid repetition across each time period. label_top_degree &lt;- function(netname, n){ degs &lt;- (netname %v% &#39;degree&#39;)[order(netname %v% &#39;degree&#39;, decreasing = T)] topdegs &lt;- unique(degs)[1:n] labels &lt;- ifelse((netname %v% &#39;degree&#39;) %in% topdegs, netname %v% &#39;name&#39;, &#39;&#39;) return(labels) } Then we can apply that function to each subgraph, specifying that we want the top 5 names for each. net1_t1 %v% &#39;labels&#39; &lt;- label_top_degree(net1_t1, n = 5) net1_t2 %v% &#39;labels&#39; &lt;- label_top_degree(net1_t2, n = 5) net1_t3 %v% &#39;labels&#39; &lt;- label_top_degree(net1_t3, n = 5) net1_t4 %v% &#39;labels&#39; &lt;- label_top_degree(net1_t4, n = 5) Now that we’ve updated our attributes, let’s plot our subgraphs. We can use the netplot_function that we wrote in the Section 5.5 and layer on a title. netplot_function(net1_t1) + labs(title = &quot;Collaborative network: Pre 1980&quot;) netplot_function(net1_t2) + labs(title = &quot;Collaborative network: 1980-1994&quot;) netplot_function(net1_t3) + labs(title = &quot;Collaborative network: 1995-2009&quot;) netplot_function(net1_t4) + labs(title = &quot;Collaborative network: 2010-2024&quot;) This is a start, but the visualization challenge here is that it is hard to really detect change because the layout changes every time. Remember, our layout algorithm wants to cluster densely connected nodes, and because those clusters shift across time periods (combined with the random element in the algorithmic calculation itself), the algorithm will move nodes to a new coordinate in each time period. To improve this visualization, then, we want nodes to be in the same position for each subgraph. So next we learn how to fix the coordinates of the nodes across multiple graphs. 4.4.3 Fixing coordinates With ggraph, we can fix coordinates by creating a layout table from our initial network. Let’s all set the same seed so that we can have the same coordinates across computers. Note that we created an ‘id’ variable earlier based on the vertex name to serve as unique identifiers in these layout tables. We’ll do that again for out no isolates network set.seed(26) net1_noiso %v% &#39;id&#39; &lt;- net1_noiso %v% &#39;vertex.names&#39; fixed_coord &lt;- create_layout(net1_noiso, layout = &#39;fr&#39;) head(fixed_coord[,c(1:8)]) ## x y degree id labels mode na ## 1 -4.525570 -9.489269 2 49590 &lt;NA&gt; 1 FALSE ## 2 -3.393409 -1.165814 10 49592 &lt;NA&gt; 1 FALSE ## 3 6.230619 -4.040640 2 49593 &lt;NA&gt; 1 FALSE ## 4 -8.142122 1.745267 8 49594 &lt;NA&gt; 1 FALSE ## 5 -2.001708 -3.333115 6 49601 &lt;NA&gt; 1 FALSE ## 6 -2.796420 1.448559 88 49602 CDFW 1 FALSE ## name ## 1 Agricultural Coalitions: Landowners membership fees ## 2 Anchor QEA ## 3 Audubon Canyon Ranch ## 4 Bachand and Associates ## 5 DOC ## 6 CDFW With these coordinates fixed from our full plot, we can then apply those same coordinates for each subgraph. To do that, we’ll first create manual layouts for each subgraph. Next we will subset the relevant coordinates from the full coordinate list using the node ‘id’. # 1. Create a layout table for the subgraph with &#39;fr&#39; coordinates coord_t1 &lt;- create_layout(net1_t1, layout = &#39;fr&#39;) # 2. Subset the relevant coordinates from the full layout table fixed_coord_t1 &lt;- fixed_coord[fixed_coord$id %in% coord_t1$id, c(&#39;x&#39;,&#39;y&#39;,&#39;id&#39;)] # 3. Overwrite the subgraph coordinates to match the fixed coordinated coord_t1$x &lt;- fixed_coord_t1$x coord_t1$y &lt;- fixed_coord_t1$y Instead of copying and pasting this over again, we’ll write a function to quickly assign the coordinates that we set as fixed to a given subgraph. To do that, we take the code we wrote above but generalize the network and fixed coordinate arguments to ‘netname’ and ‘fixed’. Then we can input any network name and any fixed coordinates, and set them all. assign_fixed_coords &lt;- function(netname, fixed){ coord_t &lt;- create_layout(netname, layout = &#39;fr&#39;) fixed_coord_t &lt;- fixed[fixed$id %in% coord_t$id, c(&#39;x&#39;,&#39;y&#39;)] coord_t$x &lt;- fixed_coord_t$x coord_t$y &lt;- fixed_coord_t$y return(coord_t) } coord_t1 &lt;- assign_fixed_coords(net1_t1, fixed_coord) coord_t2 &lt;- assign_fixed_coords(net1_t2, fixed_coord) coord_t3 &lt;- assign_fixed_coords(net1_t3, fixed_coord) coord_t4 &lt;- assign_fixed_coords(net1_t4, fixed_coord) Now we can feed these coordinates directly into the netplot_function and just add new labels. Notice that we can feed these layout data frames directly in to the function, as we would a network object. This is a great functionality of ggraph. netplot_function(coord_t1) + labs(title = &quot;Collaborative network: Pre 1980&quot;) netplot_function(coord_t2) + labs(title = &quot;Collaborative network: 1980-1994&quot;) netplot_function(coord_t3) + labs(title = &quot;Collaborative network: 1995-2009&quot;) netplot_function(coord_t4) + labs(title = &quot;Collaborative network: 2010-2024&quot;) Huh, we’re really close, but something is not quite right yet. Even though the point have the same coordinates, each version of the network does not take up the same amount of space. For example, the subgraph for the 4th time period includes University of Kansas, which is fixed at x = -8.3, so it is one of the left-most points on the network (check out coord_t4 yourself). However, University of Kansas is not included in the subgraph for the 1st time period, and the left-most node in this network is only positioned at x = -4.7 (check out coord_t1 yourself). So our issue is that the x and y axis limits adjust based on the data we input. We can just that as one more layer, specifying the widest range of x and y values in the complete network. First we can globally set these min and max axis values: xmin &lt;- min(fixed_coord$x) xmax &lt;- max(fixed_coord$x) ymin &lt;- min(fixed_coord$y) ymax &lt;- max(fixed_coord$y) netplot_function(coord_t1) + labs(title = &quot;Collaborative network: Pre 1980&quot;) + xlim(c(xmin,xmax)) + ylim(c(ymin,ymax)) netplot_function(coord_t2) + labs(title = &quot;Collaborative network: 1980-1994&quot;) + xlim(c(xmin,xmax)) + ylim(c(ymin,ymax)) netplot_function(coord_t3) + labs(title = &quot;Collaborative network: 1995-2009&quot;) + xlim(c(xmin,xmax)) + ylim(c(ymin,ymax)) netplot_function(coord_t4) + labs(title = &quot;Collaborative network: 2010-2024&quot;) + xlim(c(xmin,xmax)) + ylim(c(ymin,ymax)) For fun, we can embed these images into a gif to show how they lapse over time: Bonus code: How to create a gif from multiple plots # creates a temporary folder library(magick) library(here) netplot_function(coord_t1) + labs(title = &quot;Collaborative network: Pre 1980&quot;) + xlim(c(xmin,xmax)) + ylim(c(ymin,ymax)) ggsave(filename = file.path(here(&quot;data/animation/01.png&quot;))) netplot_function(coord_t2) + labs(title = &quot;Collaborative network: 1980-1994&quot;) + xlim(c(xmin,xmax)) + ylim(c(ymin,ymax)) ggsave(filename = file.path(here(&quot;data/animation/02.png&quot;))) netplot_function(coord_t3) + labs(title = &quot;Collaborative network: 1995-2009&quot;) + xlim(c(xmin,xmax)) + ylim(c(ymin,ymax)) ggsave(filename = file.path(here(&quot;data/animation/03.png&quot;))) netplot_function(coord_t4) + labs(title = &quot;Collaborative network: 2010-2024&quot;) + xlim(c(xmin,xmax)) + ylim(c(ymin,ymax)) ggsave(filename = file.path(here(&quot;data/animation/04.png&quot;))) imgs &lt;- list.files(here(&quot;data/animation&quot;), full.names = T) img_list &lt;- lapply(imgs, image_read) img_joined &lt;- image_join(img_list) img_animated &lt;- image_animate(img_joined, fps = .5) image_write(image = img_animated, path = here(&quot;data/animation/network.gif&quot;)) So, how have the Delta’s research collaborations changed over time? In the two earliest time periods, research collaborators were densely connected, with state and federal agencies like USGS, USBR, and USFS, and the state agency, CDFW consistently at the center. In more recent years, the number of organizations involved in research has expanded to include more state and non-governmental actors, increasing in size and decreasing in density. 4.5 Supplemental Material: Community detection For some bonus work, let’s combine some network statistics with visualization to take a deeper look at the network structure. This bonus material extends our first guiding question by asking: Do we see any particular research communities emerge across these collaborations? Often researchers are curious about whether or not there is some pattern within the network. Though the majority of the nodes are connected in one relatively dense component, are some organizations linking with others on a more regular basis? Is there a grouping trend in our network that we can’t see from the network figure on its own? To answer this, we might want to use some community detection approaches. 4.5.1 Algorithms for community detection Broadly, community detection is an approach that employs a wide range of distance/clustering algorithms to identify to find connected communities within a network based on features like density/modularity. While we’ve moved away from igraph, I do want to point out that it has a number of community detection algorithms. You can read more about community detection algorithms here. ?igraph::cluster_walktrap() ?igraph::cluster_label_prop() ?igraph::cluster_fast_greedy() In the sna package there is the equivalence cluster (equiv.cluster) function, which identifies distances based on structural equivalence. The resource above, Hoffman et al. 2018, define it as follows: ‘Structural equivalence is an important concept from the blockmodeling literature. It is defined where two nodes play the exact same role in a network in terms of their edges, and would be considered interchangeable.’ ?sna::equiv.clust() 4.5.2 Equivalence clusters &amp; block models Equivalence clustering is a clustering method which groups nodes based on distance from one another. You can specify what kinds of clustering method to use with the cluster.method argument and what distance function to use with equiv.fun, but it by default uses a hierarchical clustering method based on structural equivalence using Hamming distance. We can calculate the distance and plot a dendrogram of the clusters. ec &lt;- equiv.clust(net1_noiso) plot(ec) Now that we have these clusters, we can turn to another method, blockmodelling, which will evaluate the density of node groupings (or ‘blocks’) estimated by the equivalence clusters. We can specify how may blocks we want (k), or specify a height at which to split the classes (h). We will pick a rather arbitrary number for blocks, k = 5. bm &lt;- blockmodel(net1_noiso, ec, k = 5, glabels = &quot;DSC Collaboration&quot;) The block model output includes a vector assigning each node to a block through ‘block membership’. We can wrap this output in the table function to get a sense of how many nodes have been combined across the different blocks. Most of the nodes (97) are in block 1, while the remaning blocks are much smaller, and block 5 has only one node. table(bm$block.membership) ## ## 1 2 3 4 5 ## 97 3 8 3 1 Additionally, the block model itself provides a matrix with a density measure for the within and between block pairings. Looking along the diagonal, we see that the first block has very low density (0.03), but the smaller blocks have high within-block density (1, .89, 1), while there is no value for block 5 because the density cannot be calculated for a network of 1. bm$block.model ## Block 1 Block 2 Block 3 Block 4 Block 5 ## Block 1 0.03436426 0.2852234 0.06958763 0.1718213 0.4329897 ## Block 2 0.28522337 1.0000000 0.91666667 1.0000000 1.0000000 ## Block 3 0.06958763 0.9166667 0.89285714 0.5000000 0.7500000 ## Block 4 0.17182131 1.0000000 0.50000000 1.0000000 1.0000000 ## Block 5 0.43298969 1.0000000 0.75000000 1.0000000 NaN We can then assign the block membership to the network. It is worth noting, however, that the vector output of bm$block.membership does not maintain the same node order as the nodes in our network. So we want to make sure we reorder the membership vector to align with the vertex names, which are listed under bm$plabels. 4.5.3 Plotting block membership membership &lt;- data.frame(&quot;block&quot; = bm$block.membership, &quot;vertex.names&quot; = bm$plabels) membership &lt;- membership[order(membership$vertex.names),] net1_noiso %v% &#39;membership&#39; &lt;- membership$block ggraph(net1_noiso, layout = &#39;fr&#39;) + geom_edge_link(color = &quot;gray80&quot;) + geom_node_point(aes(size = degree, color = factor(membership)), alpha = .7) + theme_void() + labs(title = &quot;Delta Science Collaborative Research Network&quot;) + geom_node_text(aes(label = labels), size = 3, repel = T) + scale_color_viridis_d() + labs(color = &quot;Community&quot;, size = &quot;Degree&quot;) Let’s rethink our labels to get a better sense of who is in what group # Like before, set a conditional statement so that we only have labels # for nodes whose membership is in the dense nodes net1_noiso %v% &#39;member_label&#39; &lt;- ifelse(net1_noiso %v% &#39;membership&#39; %in% 2:5, net1_noiso %v% &#39;name&#39;, &quot;&quot;) We might also want to make a table of those so we can check it out data.frame(&#39;block&#39; = (net1_noiso %v% &#39;membership&#39;)[net1_noiso %v% &#39;membership&#39; %in% 2:5], &#39;name&#39; = (net1_noiso %v% &#39;name&#39;)[net1_noiso %v% &#39;membership&#39; %in% 2:5]) %&gt;% arrange(block) ## block name ## 1 2 CDFW ## 2 2 USBR ## 3 2 USFWS ## 4 3 DWR ## 5 3 CalEPA ## 6 3 SWRCB ## 7 3 Delta Stewardship Council - Delta Science Program ## 8 3 DFG ## 9 3 East Bay Municipal Utilities District ## 10 3 NMFS ## 11 3 USACE ## 12 4 NOAA ## 13 4 USDA ## 14 4 USEPA ## 15 5 USGS iso_net &lt;- ggraph(net1_noiso, layout = &#39;fr&#39;) + geom_edge_link(color = &quot;gray80&quot;) + geom_node_point(aes(size = degree, color = factor(membership)), alpha = .7) + theme_void() + labs(title = &quot;Delta Science Collaborative Research Network&quot;) + geom_node_text(aes(label = member_label), size = 3, repel = T) + scale_color_viridis_d() + labs(color = &quot;Community&quot;, size = &quot;Degree&quot;) iso_net ## Warning: ggrepel: 3 unlabeled data points (too many overlaps). Consider ## increasing max.overlaps And what if I want to clean this up, say, have only one legend and move the legend below. We can specify which legends we want with guides() and put the legend in the ‘bottom’ position with themes(). iso_net + labs(color = &quot;Community&quot;, size = &quot;Degree&quot;) + guides(color = &quot;legend&quot;, size = &quot;none&quot;) + theme(legend.position = &quot;bottom&quot;) ## Warning: ggrepel: 3 unlabeled data points (too many overlaps). Consider ## increasing max.overlaps To conclude this section we can revisit the question we set out in this supplemental code: Do we see any particular research communities emerge across these collaborations? We’ve used the blockmodel function, paired with more conditional assignments of network attributes to identify some possible research clusters. Among our five ‘blocks’ we see high density among three of them: blocks 2, 3, and 4. Block 2 includes three of the most central nodes – CDFW, USBR, USFWS – suggesting that these three wild-life and land use agencies at the state and federal levels repeatedly collaborate together in the Delta. Block 3 includes a wider variety of state agencies that are closely clustered. And block 4 has only three federal agencies, USDA, EPA, and NOAA, who much like block 2 seem to be consistently collaborating on science projects. Block 5 includes only USGS, the network’s most central node, pointing to the challenge of clustering highly central nodes given that they span so many connections. The remainder of the organizations are grouped into Block 1, a low-density mass that have no clear trend towards clustering. "],["two-mode-visualization.html", "5 Two-mode visualization 5.1 Making two-mode networks: 5.2 Guiding questions: 5.3 Representing two-mode networks 5.4 Themed projects", " 5 Two-mode visualization 5.1 Making two-mode networks: In this section we are transitioning to working with two-mode networks. That is, a network consisting of two distinctly different types of nodes, where ties are possible between (but not within) each node type. For our data, our two modes are research organizations and projects, where researchers are linked to projects based on their involvement, but in this case there is no link between projects or between researchers. We started off the workshop by creating one mode networks in igraph and network. The process for creating two-mode, or bipartite, networks is similar, though with some additional complications. Let’s make sure we have our two mode edge and node lists read in. edges_2mode &lt;- read.csv(&#39;data/edgelist_twomode.csv&#39;) nodes_2mode &lt;- read.csv(&#39;data/nodelist_twomode.csv&#39;) First, let’s discuss igraph, where two-mode networks are a bit harder to create. Generally this package has very little two-mode functionality. There is a function for creating bipartite igraphs, make_bipartite_graph(), but it requires different inputs than the standard edge list or matrix, and node lists. Instead, this function requires a vector of vertex types, meaning a Boolean of modes (0-1), and a vector of the edges in the graph. ?igraph::make_bipartite_graph() We won’t walk through the steps on how to do this, but you can reveal the steps below if you want to know more. Bonus code: How to make a two-mode network from edge list and node list in igraph # edges need to be a as a vector where each pair is a connection, # so we can vectorize the edge list (e.g. convert the connection between: # id 49590 and id 50122 be just paired together as our first two values # in the vector, and so on edges_2mode_v &lt;- as.vector(matrix(rbind(edges_2mode$org_id, edges_2mode$project_id),ncol=1)) # But edges ALSO need to be numbered in a way that is compatible with the nodelist nodes_2mode$id_numeric &lt;- 1:nrow(nodes_2mode) # So now we can reassign the edge list edges_2mode &lt;- left_join(edges_2mode, select(nodes_2mode, id, id_numeric), by = c(&#39;org_id&#39; = &#39;id&#39;)) %&gt;% rename(&#39;org_id_numeric&#39; = &#39;id_numeric&#39;) %&gt;% left_join(select(nodes_2mode, id, id_numeric), by = c(&#39;project_id&#39; = &#39;id&#39;)) %&gt;% rename(&#39;project_id_numeric&#39; = &#39;id_numeric&#39;) # And re-make this vector edges_2mode_v &lt;- as.vector(matrix(rbind(edges_2mode$org_id_numeric, edges_2mode$project_id_numeric),ncol=1)) # Now we can make the two mode network in igraph g2 &lt;- igraph::make_bipartite_graph(nodes_2mode$mode, edges_2mode_v, directed = FALSE) # And we have to manually assign attributes g2 &lt;- igraph::set_vertex_attr(g2, &quot;id&quot;, value = nodes_2mode$id) g2 &lt;- igraph::set_vertex_attr(g2, &quot;n_years&quot;, value = nodes_2mode$n_years) g2 &lt;- igraph::set_edge_attr(g2, &#39;leadership&#39;, value = edges_2mode$leadership) g2 &lt;- igraph::set_edge_attr(g2, &#39;contribution&#39;, value = edges_2mode$contribution) In the network package, we can create a bipartite network just like we did with the one-mode network, though now we want to set the bipartite argument to equal TRUE. net2 &lt;- network(x = edges_2mode, vertices = nodes_2mode, bipartite = T, directed = F) Let’s take a look at the network: net2 ## Network attributes: ## vertices = 435 ## directed = FALSE ## hyper = FALSE ## loops = FALSE ## multiple = FALSE ## bipartite = 138 ## total edges= 680 ## missing edges= 0 ## non-missing edges= 680 ## ## Vertex attribute names: ## enddate funding_org funds id_numeric mgmt_Environmentalconditions mgmt_Floodriskandlandusemanagement mgmt_Governance mgmt_Habitatmanagement mgmt_Invasivenonnativespeciesmanagement mgmt_Nativespeciesmanagement mgmt_Waterquality mgmt_Watersupplymanagement mode n_years name sci_Amphibiansandreptiles sci_Aquaticvegetation sci_Biologicalresourceuse sci_Channelizedhabitats sci_Environmentalconditions sci_Fish sci_Floodplain sci_Foodwebs sci_Habitatchanges sci_Hydrologicchanges sci_Hydrologyandhydrodynamics sci_Invasivenonnativespecies sci_Invertebrates sci_Landuseandhumanactivities sci_Mammals sci_Nutrientsenergyandfoodweb sci_Riparianhabitats sci_Sediment sci_Species sci_Terrestrialhabitats sci_Tidalwetlands sci_Waterquality sci_Weatherandclimate startdate trunc_name url vertex.names ## ## Edge attribute names: ## contribution leadership org_id_numeric project_id_numeric 5.2 Guiding questions: As we shift to working with a two-mode network, let’s again set ourselves up with some questions to guide us. With our two-mode network, we want to know: Which Delta science projects have the largest number of collaborators, and who are those collaborators? How do organizations’ activity differ across projects with different scientific and management themes: climate, land use, governance, and flooding? We will be using approaches that are similar to one-mode networks, but there are some features that we will want to rethink given that there are differences given what we can calculate and what we want to communicate. 5.3 Representing two-mode networks Analytical approaches for two-mode networks are slightly different from one-mode networks given that there are unique structural limitations of two-mode networks. As we’ve discussed already, in two-mode networks there cannot be connections between nodes of the same mode. Because of this, many approaches for summarizing and visualizing one-mode networks are not directly transferable. We’ll start with the one-mode visualization approach that we’ve started with, then build on these to improve our representation of the two-mode features. 5.3.1 The one-mode approach With one-mode networks, we used sna::degree() function to calculate the number of connections per node, and we can apply this same function to our two-mode network, net2, then run through the functions we’ve made so far to create a plot: label_top_degree() and netplot_function(). net2 %v% &#39;degree&#39; &lt;- sna::degree(net2) net2 %v% &#39;labels&#39; &lt;- label_top_degree(net2, 5) netplot_function(net2) + labs(title = &quot;Organization &amp; project bipartite research network&quot;) This is a fine start, but here we aren’t communicating anything about to two-modality of the data. Particularly when we think about our guiding question, which is about projects rather than organizations, we aren’t seeing much. Without any further specification, it just looks like a one-mode network with some central nodes. So, we want to integrate in an important node attribute of our network, mode, telling is which of those points are organizations (mode 1) and which are projects (mode 0). net2 %v% &#39;mode&#39; ## [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ## [38] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ## [75] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ## [112] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 ## [149] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [186] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [223] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [260] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [297] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [334] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [371] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [408] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 To account for mode in our visualization, we could start by adding an aesthetic feature to our visualization, changing the shape and color to be determined by mode. ggraph(net2, layout = &#39;fr&#39;) + geom_edge_link(color = &quot;gray70&quot;) + geom_node_point(aes(size = degree, shape = factor(mode), color = factor(mode)), alpha = .8) + theme_void() + scale_color_manual(values = clrs[c(7,11)]) + geom_node_text(aes(label = labels), size = 3, color=&quot;black&quot;, repel = T, max.overlaps = Inf) This network has more edges than our one-mode network, so to clean this up a little let’s make our edges thinner and more transparent. Let’s also tidy up the legend label a little. ggraph(net2, layout = &#39;fr&#39;) + geom_edge_link(width = 0.5, alpha = 0.5, color = &quot;gray70&quot;) + geom_node_point(aes(size = degree, shape = factor(mode), color = factor(mode)), alpha = .8) + theme_void() + scale_color_manual(values = clrs[c(7,11)]) + geom_node_text(aes(label = labels), size = 3, color=&quot;black&quot;, repel = T, max.overlaps = Inf) + labs(size = &quot;Degree&quot;, color = &quot;Mode&quot;, shape = &quot;Mode&quot;) So now we can see our modes, but still there are a few things that are somewhat misrepresented when we use this approach: Degree size is skewed by the limitations of the mode. Meaning: due to the nature of how two-mode networks are structured, it is likely that one mode will be more represented than the other. For instance in this case, organizations can participate in multiple projects across time, but projects are limited to the participants involved in the one time span on the project. Because of this, we see that organizations are all highest-degree, and don’t know much about the projects that are highly collaborative. The layout of the network hides that within-mode connections are not possible. By using one of the more classical layout algorithms that try to limit distance and group similar nodes, it is hard to notice that no two green triangles are connected to one another, nor are there any connections between the circles. So let’s address each of these points. 5.3.2 Assign top labels based on project mode Instead of assigning labels based on overall degree, we want to calculate the top degrees for just the projects, then the identify the organization nodes who are associated with those top projects. We can use the same skeleton of the code as before, but tweak it to address our question. # projects are mode 0, so these are interesting to our question degs_mode0 &lt;- (net2 %v% &#39;degree&#39;)[net2 %v% &#39;mode&#39; == 0] degs_mode0 &lt;- degs_mode0[order(degs_mode0, decreasing = T)] topdegs_mode0 &lt;- unique(degs_mode0)[1] # identify the most popular projects with labels net2 %v% &#39;labels_bip&#39; &lt;- ifelse((net2 %v% &#39;degree&#39;) %in% topdegs_mode0 &amp; net2 %v% &#39;mode&#39; == 0, net2 %v% &#39;name&#39;, NA) Now it is these labels that we can use to identify organization linkages (net2 %v% &#39;labels_bip&#39;)[!is.na(net2 %v% &#39;labels_bip&#39;)] ## [1] &quot;National Water Use Science Project [NWUSP]&quot; # make a vector of the top projects top_projs &lt;- (net2 %v% &#39;vertex.names&#39;)[!is.na(net2 %v% &#39;labels_bip&#39;)] # identify the organizations associated with top projects using the edge list related_orgs &lt;- edges_2mode$org_id[edges_2mode$project_id %in% top_projs] # rename the labels based on whether or not a node is in the related orgs net2 %v% &#39;labels_bip&#39; &lt;- ifelse((net2 %v% &#39;vertex.names&#39;) %in% related_orgs &amp; net2 %v% &#39;mode&#39; == 1, net2 %v% &#39;name&#39;, net2 %v% &#39;labels_bip&#39;) Now we can label the nodes by ‘labels_bip’. ggraph(net2, layout = &#39;fr&#39;) + geom_edge_link(width = 0.5, alpha = 0.5, color = &quot;gray70&quot;) + geom_node_point(aes(size = degree, shape = factor(mode), color = factor(mode)), alpha = .8) + theme_void() + scale_color_manual(values = clrs[c(7,11)]) + geom_node_text(aes(label = labels_bip), size = 3, color=&quot;black&quot;, repel = T, max.overlaps = Inf) + labs(size = &quot;Degree&quot;, color = &quot;Mode&quot;, shape = &quot;Mode&quot;) 5.3.3 Bipartite layout Next, I want to reconsider layouts that help demonstrate the structural limitations between modes: that there can be no connections between projects or between collaborators. The ‘bipartite’ layout minimizes edge crossing and lines up modes next to one another. However, this layout requires a T/F ‘type’ variable to define the mode, so we can create that using our mode variable. net2 %v% &#39;type&#39; &lt;- ifelse(net2 %v% &#39;mode&#39; == 0, T, F) Now we can specify the layout to bipartite: ggraph(net2, layout = &#39;bipartite&#39;) + geom_edge_link(width = 0.5, alpha = 0.5, color = &quot;gray70&quot;) + geom_node_point(aes(size = degree, shape = factor(mode), color = factor(mode)), alpha = .8) + theme_void() + scale_color_manual(values = clrs[c(7,11)]) + geom_node_text(aes(label = labels_bip), size = 3, color=&quot;black&quot;, repel = T, max.overlaps = Inf) + labs(size = &quot;Degree&quot;, color = &quot;Mode&quot;, shape = &quot;Mode&quot;) So, which Delta science projects have the largest number of collaborators, and who are those collaborators? We plot only the project with the largest number of collaborators: National Water Use Science Project. This project heads up the USGS “Water Census”, and has been running since 1950 with 11 different actors involved, largely federal agencies. Some of those agencies, like USFS, are among the most active in the network, but others like USDA are more peripheral. 5.3.4 Functions What we’ve set up so far feels like a solid foundation for a bipartite plotting function, so as before, let’s bundle this up into a function to use more later by just replacing the name of the network, net2, with a generic ‘netname’. plot_bipartite_fx &lt;- function(netname){ p &lt;- ggraph(netname, layout = &#39;bipartite&#39;) + geom_edge_link(width = 0.5, alpha = 0.5, color = &quot;gray70&quot;) + geom_node_point(aes(size = degree, shape = factor(mode), color = factor(mode)), alpha = .8) + theme_void() + scale_color_manual(values = clrs[c(7,11)]) + geom_node_text(aes(label = labels_bip), size = 3, color=&quot;black&quot;, repel = T, max.overlaps = Inf) + labs(size = &quot;Degree&quot;, color = &quot;Mode&quot;, shape = &quot;Mode&quot;) return(p) } We can also set ourselves up by making another function to assign labels for the top projects and their associated organizations: assign_bipartite_labels &lt;- function(netname, n){ degs_mode0 &lt;- (netname %v% &#39;degree&#39;)[netname %v% &#39;mode&#39; == 0] degs_mode0 &lt;- degs_mode0[order(degs_mode0, decreasing = T)] topdegs_mode0 &lt;- unique(degs_mode0)[1:n] netname %v% &#39;labels_bip&#39; &lt;- ifelse((netname %v% &#39;degree&#39;) %in% topdegs_mode0 &amp; netname %v% &#39;mode&#39; == 0, netname %v% &#39;name&#39;, NA) top_projs &lt;- (netname %v% &#39;vertex.names&#39;)[!is.na(netname %v% &#39;labels_bip&#39;)] related_orgs &lt;- edges_2mode$org_id[edges_2mode$project_id %in% top_projs] labels &lt;- ifelse((netname %v% &#39;vertex.names&#39;) %in% related_orgs &amp; netname %v% &#39;mode&#39; == 1, netname %v% &#39;name&#39;, netname %v% &#39;labels_bip&#39;) return(labels) } 5.4 Themed projects Lets now turn to think more about nodes with the second guiding question: How do organizations’ activity differ across projects with different scientific and management themes: climate, land use, governance, and flooding? Where we previously induced subgraphs based on edge attributes, we now want to compare subgraphs based on node attributes. Let’s get to it. 5.4.1 Inducing bipartite network by nodes We have scientific and management themes attributes to different projects, and we can identify the nodes for which those attributes are true. climate &lt;- which(net2 %v% &#39;sci_Weatherandclimate&#39; == T) landuse &lt;- which(net2 %v% &#39;sci_Landuseandhumanactivities&#39; == T) govnc &lt;- which(net2 %v% &#39;mgmt_Governance&#39; == T) flood &lt;- which(net2 %v% &#39;mgmt_Floodriskandlandusemanagement&#39; == T) head(climate) ## [1] 155 189 365 390 391 397 However, we only have this theme attribute for nodes in the project mode, which means that the induced network will have zero edges – it is not possible for projects to have ties to one another. net2_cli &lt;- get.inducedSubgraph(net2, v = climate) net2_cli ## Network attributes: ## vertices = 9 ## directed = FALSE ## hyper = FALSE ## loops = FALSE ## multiple = FALSE ## bipartite = 0 ## total edges= 0 ## missing edges= 0 ## non-missing edges= 0 ## ## Vertex attribute names: ## degree degree_norm_bip enddate funding_org funds id_numeric labels labels_bip mgmt_Environmentalconditions mgmt_Floodriskandlandusemanagement mgmt_Governance mgmt_Habitatmanagement mgmt_Invasivenonnativespeciesmanagement mgmt_Nativespeciesmanagement mgmt_Waterquality mgmt_Watersupplymanagement mode n_years name sci_Amphibiansandreptiles sci_Aquaticvegetation sci_Biologicalresourceuse sci_Channelizedhabitats sci_Environmentalconditions sci_Fish sci_Floodplain sci_Foodwebs sci_Habitatchanges sci_Hydrologicchanges sci_Hydrologyandhydrodynamics sci_Invasivenonnativespecies sci_Invertebrates sci_Landuseandhumanactivities sci_Mammals sci_Nutrientsenergyandfoodweb sci_Riparianhabitats sci_Sediment sci_Species sci_Terrestrialhabitats sci_Tidalwetlands sci_Waterquality sci_Weatherandclimate startdate trunc_name type url vertex.names ## ## No edge attributes So we also need to identify the organization alters related to the relevant projects. climate_alter_ids &lt;- edges_2mode$org_id[edges_2mode$project_id %in% (net2 %v% &#39;vertex.names&#39;)[climate]] landuse_alter_ids &lt;- edges_2mode$org_id[edges_2mode$project_id %in% (net2 %v% &#39;vertex.names&#39;)[landuse]] govnc_alter_ids &lt;- edges_2mode$org_id[edges_2mode$project_id %in% (net2 %v% &#39;vertex.names&#39;)[govnc]] flood_alter_ids &lt;- edges_2mode$org_id[edges_2mode$project_id %in% (net2 %v% &#39;vertex.names&#39;)[flood]] This approach gets us nearly there. We have their actual ids, but when we induce a network we want to use their numeric representation in the network object, so we have to further extract that. climate_alters &lt;- which(net2 %v% &#39;vertex.names&#39; %in% climate_alter_ids) landuse_alters &lt;- which(net2 %v% &#39;vertex.names&#39; %in% landuse_alter_ids) govnc_alters &lt;- which(net2 %v% &#39;vertex.names&#39; %in% govnc_alter_ids) flood_alters &lt;- which(net2 %v% &#39;vertex.names&#39; %in% flood_alter_ids) Now we have the ego’s location in the network, which we can set to our v argument, and their alter’s location in the network, which we can set to our alter argument. net2_cli &lt;- network::get.inducedSubgraph(net2, v = climate, alters = climate_alters) net2_landuse &lt;- network::get.inducedSubgraph(net2, v = landuse, alters = landuse_alters) net2_govnc &lt;- network::get.inducedSubgraph(net2, v = govnc, alters = govnc_alters) net2_flood &lt;- network::get.inducedSubgraph(net2, v = flood, alters = flood_alters) We get a warning: ‘I hope you know what you’re doing…’. Me too. Assuming we do, let’s take a look: net2_flood ## Network attributes: ## vertices = 83 ## directed = FALSE ## hyper = FALSE ## loops = FALSE ## multiple = FALSE ## bipartite = 39 ## total edges= 114 ## missing edges= 0 ## non-missing edges= 114 ## ## Vertex attribute names: ## degree degree_norm_bip enddate funding_org funds id_numeric labels labels_bip mgmt_Environmentalconditions mgmt_Floodriskandlandusemanagement mgmt_Governance mgmt_Habitatmanagement mgmt_Invasivenonnativespeciesmanagement mgmt_Nativespeciesmanagement mgmt_Waterquality mgmt_Watersupplymanagement mode n_years name sci_Amphibiansandreptiles sci_Aquaticvegetation sci_Biologicalresourceuse sci_Channelizedhabitats sci_Environmentalconditions sci_Fish sci_Floodplain sci_Foodwebs sci_Habitatchanges sci_Hydrologicchanges sci_Hydrologyandhydrodynamics sci_Invasivenonnativespecies sci_Invertebrates sci_Landuseandhumanactivities sci_Mammals sci_Nutrientsenergyandfoodweb sci_Riparianhabitats sci_Sediment sci_Species sci_Terrestrialhabitats sci_Tidalwetlands sci_Waterquality sci_Weatherandclimate startdate trunc_name type url vertex.names ## ## Edge attribute names: ## contribution leadership org_id_numeric project_id_numeric Look’s alright. So now let’s assign the appropriate labels to each of these subgraphs. net2_cli %v% &#39;labels_bip&#39; &lt;- assign_bipartite_labels(net2_cli, 1) net2_landuse %v% &#39;labels_bip&#39; &lt;- assign_bipartite_labels(net2_landuse, 1) net2_govnc %v% &#39;labels_bip&#39; &lt;- assign_bipartite_labels(net2_govnc, 1) net2_flood %v% &#39;labels_bip&#39; &lt;- assign_bipartite_labels(net2_flood, 1) Last, we want to plot them! plot_bipartite_fx(net2_cli) + labs(title = &quot;Scientific theme: Climate&quot;) plot_bipartite_fx(net2_landuse) + labs(title = &quot;Scientific theme: Land use&quot;) plot_bipartite_fx(net2_govnc) + labs(title = &quot;Management theme: Governance&quot;) plot_bipartite_fx(net2_flood) + labs(title = &quot;Management theme: Flooding&quot;) How do organizations’ activity differ across projects with different scientific and management themes: climate, land use, governance, and flooding? "],["additional-resources.html", "6 Additional resources 6.1 Interactive networks 6.2 Useful tutorials 6.3 Other plotting packages", " 6 Additional resources 6.1 Interactive networks 6.1.1 visNetwork #install.packages(&#39;visNetwork&#39;) library(visNetwork) edges_visnet &lt;- edges_1mode colnames(edges_visnet)[c(1,2)] &lt;- c(&#39;from&#39;, &#39;to&#39;) nodes_visnet &lt;- nodes_1mode colnames(nodes_visnet)[2] &lt;- &#39;label&#39; visNetwork(nodes_visnet, edges_visnet, width=&quot;100%&quot;, height=&quot;400px&quot;) 6.1.2 networkD3 #install.packages(&#39;networkD3&#39;) library(networkD3) nodesd3 &lt;- nodes_1mode[1] nodesd3$zero_id &lt;- 0:(nrow(nodesd3)-1) edgesd3 &lt;- edges_1mode edgesd3 &lt;- dplyr::left_join(edgesd3, nodesd3, by = c(&#39;from_org_id&#39; = &#39;id&#39;)) colnames(edgesd3)[7] &lt;- &#39;from_zero_id&#39; edgesd3 &lt;- dplyr::left_join(edgesd3, nodesd3, by = c(&#39;to_org_id&#39; = &#39;id&#39;)) colnames(edgesd3)[8] &lt;- &#39;to_zero_id&#39; nodesd3$name &lt;- nodes_1mode$name forceNetwork(Links = edgesd3, Nodes = nodesd3, Source=&quot;from_zero_id&quot;, Target=&quot;to_zero_id&quot;, NodeID = &quot;name&quot;, Group = 1, linkWidth = 1, linkColour = &quot;#afafaf&quot;, fontSize=12, zoom=T, opacity = 0.8, charge=-300, width = 600, height = 400) 6.2 Useful tutorials Katya Ognyanova’s Network Visualization tutorials from PolNet have always been a great starting point for features across several packages 6.3 Other plotting packages There are several plotting packages out there, some of them work with different network objects and requiring different knowledge. Excellent overviews of some of them are provided in this post by Katya Ognyanova. I won’t need to repeat these, but it is worth seeing the basic representation and understanding how igraph vs. network objects look differently in them, by default. 6.3.1 plot() Base R plotting works with network and igraph objects, though their defaults for each object are different. plot(net1) plot(g1) 6.3.2 GGally::ggnet2() The ggnet2 function is also dynamic, but despite being housed as part of the GGally extension of the ggplot2 series it seems to function more like a base R plot. For this function, igraph and network objects look the same. GGally::ggnet2(net1) GGally::ggnet2(g1) 6.3.3 ggnetwork::ggnetwork() Very similar to ggraph and also an extension of the ggplot family is the ggnetwork function. This function integrates directly with ggplot2 and specifies the default coordinates of ggraph, but otherwise operates quite similarly. For this function, igraph and network objects look the same. library(ggplot2) library(ggnetwork) ggplot(net1, aes(x = x, y = y, xend = xend, yend = yend)) + geom_nodes() + geom_edges() ggplot(g1, aes(x = x, y = y, xend = xend, yend = yend)) + geom_nodes() + geom_edges() "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
