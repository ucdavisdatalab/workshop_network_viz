[["index.html", "Network Visualization Overview 0.1 Description 0.2 Learning goals 0.3 Prerequisites", " Network Visualization Liza Wood 2023-03-28 Overview 0.1 Description Network science approaches are being increasingly used to explore complext interactions and the general connectivity among entities, from friends in a social network to the spread of a disease in a population. Due its complexity, network data is often best explored and communicated using data visualizations. In this intermediate R workshop we will cover how to tell useful stories with network data primarily using the ‘statnet’ suite of packages and the ‘ggraph’ plotting package that is compatible with much of the ggplot2 framework. In this interactive and hands-on workshop we’ll practice using these packages in R to plot one-mode and two-mode networks. As we introduce functions unique to these packages we will discuss what visualization features best suit different types of network data and research communication goals. Along the way we will cover basic data preparation steps and how to calculate (or assign) key network descriptives including centrality measures, edge attributes, and community clusters for your plots. 0.2 Learning goals After completing this workshop, learners should be able to: Distinguish between ‘igraph’ and ‘network’ objects in R Identify the necessary components for visualizing network objects in ggraph Calculate network and node-level descriptives and integrate them into visualizations Select among various visualization strategies for diverse communication goals Create well-designed network figures Identify where to go to learn more 0.3 Prerequisites The target audience for this workshop is intermediate to advanced R users. This workshop will provide only a cursory introduction to network data and therefore is best suited for learners who have some familiarity working with networks. While workshop examples will be based primarily on social scientific examples (e.g., social connections and co-occurrence networks), network visualizations can be applied to a wide variety of research questions and learners from all domains are welcome. "],["introduction.html", "1 Introduction 1.1 What are network data? 1.2 Storing network data", " 1 Introduction 1.1 What are network data? Networks are composed of are relational data, whereby entities across all types of domains (actors, companies, species, topics, etc.) are connected based on certain kinds of relationships (friendship, trade, pollination, in-text co-occurrence, etc.) Networks are useful for studying interdependencies; their structure suggest that entities and their connections inter-relate. Though interdependent, most (social, at least) theory is often framed in terms of selection, nodes are choosing to make connections based on certain characteristics/decision criteria, or in terms of influence, connections are affecting the characteristics/decisions of actors. 1.1.1 Features of a network Networks are composed of ‘nodes’, the data points that represent and entity (also called vertex), and ‘edges’, representing the relationship between the nodes. These network structures are represented in Figure 1. library(statnet) library(ggraph) library(magrittr) library(kableExtra) # From Jared set.seed(10) # Setting the random seed will control how networks are gnerated, included here to try and make uniform across participant&#39;s computers e.m = sna::rgraph(2, mode=&quot;graph&quot;, tprob = .4) # &#39;rgraph&#39; creates a random matrix using parameters supplied, which can be interpreted as a network (xplained more in the data section) e.n = network::network(e.m, matrix.type = &quot;adjacency&quot;, directed = FALSE) # The &#39;network&#39; command turns data into a network object, which is required for later analyses plot(e.n, label = &quot;Node&quot;, edge.label = &quot;edge&quot;, vertex.cex = 3, vertex.col = &quot;#357BA2FF&quot;) Network ‘mode’: Networks can take several forms with variation in what kinds of connections can occur. One important distinction can be made between one-mode and two-mode networks. One-mode networks assumes that the nodes are all capable of making connections while two-mode networks assume that nodes of one type can only have relationships to nodes of a different type. Using the example of board members and corporations, Jasny (2012) explains: ‘Ties between the board members themselves (e.g., friendship ties) would constitute a one-mode network. Ties between companies (e.g., if the first company supplied the second with raw materials) would also be a one-mode network. The two-mode network is formed by ties from the board members, the first mode, to the boards of companies they sit on, the second mode.’ These two-mode networks, also called bipartite networks, assume that connections cannot be made within each mode. Node attributes:In both one and two mode networks, nodes have attributes. Node attributes are associated data that describe the entity, which can be either endogenous to the network (i.e. a characteristic of the node based on their place in the network) or exogenous (i.e. a characteristic of the node unrelated to their place in the network). Examples of endogenous node attributes are described in the X Section. Examples of exogenous node attributes could be the gender of an individual, the sector a company works in, the weight or species of a pollinator, or the author of a word’s corpus. Directionality: The connections that connect entities in a network can be directed or undirected. Directed networks assume that there is a ‘sender’ and ‘receiver’ of an edge, and that the difference between these two matter (e.g. transmitting a disease). On the other hand, undirected networks assume that the connection is based on a mutual relationship (e.g. co-authorship). Whether or not edges are connected will alter our understanding of the network structure, since each connection-based statistic will be divided into incoming and outgoing connections. Edge attributes: Just like with nodes, edges can also have attributes. Edge attributes are exogenous data that describe the connection, such as the ‘weight’ of the tie (multiple connections) and/or the type of connection. For example, individuals in a network can be connected through different relationships (e.g. classmates, friends), companies can trade information and/or material goods; pollinators can visit or pollinate. Depending on how a researcher wants to analyze a network, these various types of connections can be considered to exist across multiple ‘levels’. 1.1.2 Network statistics Network-level statistics Size: Number of nodes and/or number of connections Density: Number of edges out of all possible edges Centralization: propensity for nodes to connect to few or many nodes; closely related to degree distribution Transitivity: propensity for ‘triadic closure’ Actor-level Degree centrality: Number of connections per node 1.2 Storing network data Network data, which record the relationships (edges) between nodes, are typically stored in one of two ways: edge lists or matrices. Edge lists are columns of data, whereby the positioning of two nodes next to one another in a column indicates a connection. In a one-mode undirected network, the position of names in the columns have little meaning (A -&gt; B = B &lt;- A). In a one-mode directed network, however, the columns take on a meaning, where the first column is a list of names from which a connection originated (e.g. ‘from’, also called ‘ego’), and the second column is a list of names to whom the connection is made (e.g. ‘to’, also called ‘alter’). In these cases, A -&gt; B != B -&gt; A. In two-made networks, where nodes of mode 1 can only connect to nodes of mode 2, but not one another, each column will represent a mode and nodes listed in one column cannot be in the other. data.frame(&#39;ego&#39; = LETTERS[1:10], &#39;alter&#39; = LETTERS[c(2,2,8,5,7,3,8,10,1,6)]) %&gt;% kable(align = &#39;c&#39;, caption = &#39;One-mode edge list&#39;) %&gt;% kable_styling() Table 1.1: One-mode edge list ego alter A B B B C H D E E G F C G H H J I A J F data.frame(&#39;mode1&#39; = LETTERS[1:10], &#39;mode2&#39; = LETTERS[c(15,11,11,13,12,12,15,14,14,11)]) %&gt;% kable(align = &#39;c&#39;, caption = &#39;Two-mode edge list&#39;) %&gt;% kable_styling() Table 1.1: Two-mode edge list mode1 mode2 A O B K C K D M E L F L G O H N I N J K Matrices are the graph form for storing relational data. Nodes are listed as the rows and columns, and if two nodes are connected, a value is put into the matrix where they intersect. If two nodes do not have a connection, the value at their intersection is zero. The differences we pointed out in edge lists (directed/undirected, one-mode/two-mode) are reflected in the shape and symmetry of the matrix. One-mode undirected networks are square (i.e. the same nodes are represented in both the rows and columns) and symmetrical (i.e. the values across the diagonal are the same). In one-mode directed networks, the matrix is still square but the matrix is asymmetric: because it may be that nodeA -&gt; nodeB, inputting a value of 1 in row 1 and column 2, but if nodeB !-&gt; nodeA, there is a value of 0 in row 2 and column 1. In a two-mode network the matrix is likely rectangular, where mode one nodes are represented in the rows and mode two nodes are represented in the columns. Typically, two mode networks are not directed. data.frame(&#39;ego&#39; = LETTERS[1:10], &#39;alter&#39; = LETTERS[c(2,3,8,5,7,3,8,10,1,6)]) %&gt;% network(directed = T) %&gt;% as.matrix.network.adjacency() %&gt;% kable(align = &#39;c&#39;, caption = &#39;Undirected one-mode adjacency matrix&#39;) %&gt;% kable_styling() Table 1.2: Undirected one-mode adjacency matrix A B C D E F G H I J A 0 1 0 0 0 0 0 0 0 0 B 0 0 1 0 0 0 0 0 0 0 C 0 0 0 0 0 0 0 1 0 0 D 0 0 0 0 1 0 0 0 0 0 E 0 0 0 0 0 0 1 0 0 0 F 0 0 1 0 0 0 0 0 0 0 G 0 0 0 0 0 0 0 1 0 0 H 0 0 0 0 0 0 0 0 0 1 I 1 0 0 0 0 0 0 0 0 0 J 0 0 0 0 0 1 0 0 0 0 data.frame(&#39;mode1&#39; = LETTERS[1:10], &#39;mode2&#39; = LETTERS[c(15,11,11,13,12,12,15,14,14,11)]) %&gt;% network(directed = F, bipartite = T) %&gt;% as.matrix.network.adjacency() %&gt;% kable(align = &#39;c&#39;, caption = &#39;Undirected two-mode adjacency matrix&#39;) %&gt;% kable_styling() Table 1.2: Undirected two-mode adjacency matrix O K M L N A 1 0 0 0 0 B 0 1 0 0 0 C 0 1 0 0 0 D 0 0 1 0 0 E 0 0 0 1 0 F 0 0 0 1 0 G 1 0 0 0 0 H 0 0 0 0 1 I 0 0 0 0 1 J 0 1 0 0 0 "],["data.html", "2 Data 2.1 Delta Science Tracker 2.2 Data descriptions 2.3 Guiding questions", " 2 Data 2.1 Delta Science Tracker This workshop uses publicly available data from the Delta Stewardship Council’s (DSC) Delta Science Tracker. This database is a library of Sacramento and San Joaquin Delta-related research over the last 50 years. As the DSC’s website explains: “The Delta Science Tracker is a tool to improve coordination and collaboration of science activities in a way that is valuable to scientists, decision-makers, and managers in the Delta. The Delta Science Tracker allows users to explore and visualize recent research and monitoring efforts through the lenses of science activities, organizations, and people. It is intended to promote communication, create opportunities for collaboration, and enhance transparency for science funding opportunities and decisions.” The data we’re using was downloaded from the DSC’s visualizations page, with the ‘collaborations by’ filter set to organizations. Additional data was downloaded through scraping their webpage, which we did with permission from the DSC. Code for scraping their webpage can be found here. 2.2 Data descriptions Before getting started with visualizations, we want to take a look at the data we have available. Typical questions you should be able to answer based on your network data are as follows: What types of nodes do we have and how are they related? Are there any node and/or edge attributes are available? Are the network data one or two mode? Directed or undirected? Let’s take a look at what we have. Two-mode edge list: The DSC data was originally compiled as two-mode network data, describing how organizations/researchers are connected to research projects. In these data, our first mode, project_id, is the id numbers representing different Delta science research projects. And our second mode, org_id, is the organization(s) (agencies, universities, etc) that are working on that project. This two-mode edge list has 680 rows, whereby 138 organizations are connected with one or more of 297 projects. In these data, organizations often take part in more than one project, and projects often have more than one organizations associated with it. We also have edge attributes, which represent the kind of involvement an organization has in the project: contributor or leader. edges_2mode &lt;- read.csv(&#39;data/edgelist_twomode.csv&#39;) head(edges_2mode) ## org_id project_id contribution leadership ## 1 49590 50122 TRUE FALSE ## 2 49592 49780 TRUE FALSE ## 3 49592 49865 TRUE FALSE ## 4 49594 49860 TRUE FALSE ## 5 49598 50091 TRUE FALSE ## 6 49600 50170 TRUE FALSE Two-mode node list: We have a two-mode list of all the nodes (organizations and projects). We have more node attributes for project nodes than we do for organization nodes, so many of the attributes for organizations are empty. For projects, we have funding data, the dates of the project, as well as a series of categorical tags related to what kinds of scientific and management themes the project addresses. A sample of those are displayed below: nodes_2mode &lt;- read.csv(&#39;data/nodelist_twomode.csv&#39;) head(nodes_2mode[,c(1,4:6,16,31,39)]) ## id funds startdate enddate sci_Floodplain mgmt_Waterquality mode ## 1 50122 $0 2008 2019 FALSE TRUE 0 ## 2 49780 $0 2020 2021 FALSE FALSE 0 ## 3 49865 $445,921 2019 2022 FALSE FALSE 0 ## 4 49860 $931,104 2019 2022 FALSE FALSE 0 ## 5 50091 $0 NA NA FALSE FALSE 0 ## 6 50170 $0 NA NA FALSE FALSE 0 Note that the scientific and management themes are formatted as Boolean values for each theme. This is because projects can have more than one theme, and so listing them out would cause our data to be ‘long’ with repeated project observations. With node lists, we want to only have unique observations. If your data are ‘long’ (with repeating observations), widen them out as we did with the scientific and management themes. One-mode edge list: We projected our two-mode network to a one-mode network to take a deeper look at research collaborations. Projection of two-mode data into one-mode is a common practice, though it has its limitations (Jasny 2012). By converting two-mode into one-mode data, we can take a look at what organizations are working together on projects. We’ve also added in an edge attribute to our collaboration tie based on the years that different actors collaborated together. See below for a hint on how to project one-mode data from two-mode data. edges_1mode &lt;- read.csv(&#39;data/edgelist_projected.csv&#39;) head(edges_1mode) ## from_org_id to_org_id Y1995_2009 Y2010_2024 before_1980 Y1980_1994 ## 1 49590 49709 TRUE FALSE FALSE FALSE ## 2 49592 49708 FALSE TRUE FALSE FALSE ## 3 49592 49741 FALSE TRUE FALSE FALSE ## 4 49592 49609 FALSE TRUE FALSE FALSE ## 5 49708 49741 FALSE TRUE FALSE FALSE ## 6 49609 49708 FALSE TRUE FALSE FALSE Reveal: How to project one-mode networks from two-mode edge list # We got our projected data directly from the DST webpage, but generally, # you can project any bipartite network into a one-mode network using the # following steps: # 1. Create count table where organizations are columns (make your mode of # interest the 2nd/y argument in the table) tbl &lt;- table(edges_2mode[c(2,1)]) # 2. Extract column names -- these are mode 1 names (in our case, orgs) orgids &lt;- colnames(tbl) # 3. Take the cross-product of the table to get a co-occurence matrix comat &lt;- crossprod(tbl) # 4. Assign self-co-occurrences 0 diag(comat) &lt;- 0 # Check: This should be symmetrical isSymmetric(comat) # 5. Make a data frame from the matrix and add ids as the column names comat &lt;- data.frame(comat) colnames(comat) &lt;- orgids #. Check: This should be square dim(comat) # 6. Remove those with no co-occurrence at all comat &lt;- comat[rowSums(comat, na.rm = T) != 0, colSums(comat, na.rm = T) != 0] # 7. Make co-occur data frame into matrix object comat &lt;- as.matrix(comat) # 8. Create a graph so that it can be converted into a weighted edge list g &lt;- igraph::graph_from_adjacency_matrix(comat, weighted = T, mode = &#39;undirected&#39;) el_proj &lt;- igraph::get.data.frame(g) One-mode node list: We reduced our two-mode node list down to only a list of our organization nodes, which is what we project in our one-mode network. For organizations, we have very few attributes, only their id, name, and link to their DST page. nodes_1mode &lt;- read.csv(&#39;data/nodelist_onemode.csv&#39;) head(nodes_1mode[1:2]) ## id name ## 1 49590 Agricultural Coalitions: Landowners membership fees ## 2 49592 Anchor QEA ## 3 49593 Audubon Canyon Ranch ## 4 49594 Bachand and Associates ## 5 49598 BTS ## 6 49600 CalFish 2.3 Guiding questions As with any visualization, we need to have an idea of what stories we want to tell / what questions we want to answer. With networks, there are limits to how much you can ‘explore’ through visualization alone, and so throughout these plotting exercises having guiding questions can keep you focused on what is important as we navigate the wide array of visualization options. 2.3.1 One-mode visualization: What is the structure of the collaborative research network research in the Delta? Do we see any particular research communities emerge across these collaborations? (community detection + representing node attributes by color) How have those collaborations changed over time? (subgraphs based on edge attribute + multiple plots with fixed coordinates) 2.3.2 Two-mode visualization: Across the Delta science project, what organizations have been most active? How do organizations’ activity differ across different scientific and management themes: climate, land use, governance, and flooding? (subgraphs based on edge attribute) Are most-active members typically leaders or contributors? (make subgraphs based on edge attribute + make multiple plots with fixed coordinates) "],["creating-network-objects-in-r.html", "3 Creating network objects in R 3.1 igraph 3.2 network", " 3 Creating network objects in R Now that we have our edge lists and node lists, we want to create our network objects. There are two popular network packages (and consequently, network object types) in R. igraph generates a list object of class “igraph” and network generates an list object of class “network”. We are going to be working primarily with network objects, but I’d like to start by making both because you are likely to run into both of them along the way, and both are compatible with the ggraph package that we will be using. First, let’s read in our two network packages, as well as a couple other packages that we’ll need for this workshop. library(igraph) library(network) library(dplyr) library(magrittr) 3.1 igraph First, let’s make an igraph object. igraph generally seems to have more documentation/Stack Overflow resources than other network packages, so it might be tempting to start here. We can load in the igraph package and use the graph_from_data_frame() function to create our graph. Note that there are dozens of graph_from... functions. Many of them sound (and are) intuitive. When dealing with edge and node lists, I prefer graph_from_data_frame() over graph_from_edgelist() because the former allows us to include the node list as an argument, whereas the latter does not. We want to start with creating both our one and two-mode networks. For our one-mode networks we want to use the edges_1mode and nodes_1mode objects. g1 &lt;- graph_from_data_frame(edges_1mode, vertices = nodes_1mode, directed = F) We can take a look at a summary of the igraph object below. We see the number of nodes (139) and edges (475) summarized at top and our list of node attributes (followed by (v/[datatype])) and edges attributes (followed by (e/[datatype])). summary(g1) ## IGRAPH cee615b UN-- 139 475 -- ## + attr: name (v/c), url (v/c), mode (v/n), Y1995_2009 (e/l), Y2010_2024 ## | (e/l), before_1980 (e/l), Y1980_1994 (e/l) Two-mode networks are a bit harder to create in igraph. Generally this package has very little two-mode functionality. There is one function for this, make_bipartite_graph(), but it requires different inputs than the standard edge list or matrix, and node lists. Instead, this function requires a vector of vertex types, meaning a Boolean of modes (0-1), and a vector of the edges in the graph. ?make_bipartite_graph() We won’t walk through the steps on how to do this, but you can reveal the steps below if you want to know more. Reveal: How to make a two-mode network from edge list and node list in igraph # edges need to be a as a vector where each pair is a connection, # so we can vectorize the edge list (e.g. convert the connection between: # id 49590 and id 50122 be just paired together as our first two values # in the vector, and so on edges_2mode_v &lt;- as.vector(matrix(rbind(edges_2mode$org_id, edges_2mode$project_id),ncol=1)) # But edges ALSO need to be numbered in a way that is compatible with the nodelist nodes_2mode$id_numeric &lt;- 1:nrow(nodes_2mode) # So now we can reassign the edge list library(dplyr) library(magrittr) edges_2mode &lt;- left_join(edges_2mode, select(nodes_2mode, id, id_numeric), by = c(&#39;org_id&#39; = &#39;id&#39;)) %&gt;% rename(&#39;org_id_numeric&#39; = &#39;id_numeric&#39;) %&gt;% left_join(select(nodes_2mode, id, id_numeric), by = c(&#39;project_id&#39; = &#39;id&#39;)) %&gt;% rename(&#39;project_id_numeric&#39; = &#39;id_numeric&#39;) # And re-make this vector edges_2mode_v &lt;- as.vector(matrix(rbind(edges_2mode$org_id_numeric, edges_2mode$project_id_numeric),ncol=1)) # Now we can make the two mode network in igraph g2 &lt;- make_bipartite_graph(nodes_2mode$mode, edges_2mode_v, directed = FALSE) # And we have to manually assign attributes g2 &lt;- set_vertex_attr(g2, &quot;id&quot;, value = nodes_2mode$id) g2 &lt;- set_vertex_attr(g2, &quot;n_years&quot;, value = nodes_2mode$n_years) g2 &lt;- set_edge_attr(g2, &#39;leadership&#39;, value = edges_2mode$leadership) g2 &lt;- set_edge_attr(g2, &#39;contribution&#39;, value = edges_2mode$contribution) Still, we can take a look. Much like the one-mode graph, we see the number of nodes (now 435) and edges (680) summarized at top and our list of node attributes and edges attributes. g2 ## IGRAPH e74662d U--B 435 680 -- ## + attr: type (v/l), id (v/n), n_years (v/n), leadership (e/l), ## | contribution (e/l) ## + edges from e74662d: ## [1] 1--298 2--299 3--299 4--301 5--302 6--303 7--304 8--305 9--305 ## [10] 10--305 11--305 12--305 13--305 14--305 15--305 16--305 17--305 18--305 ## [19] 19--305 20--305 21--305 22--305 23--305 24--305 25--305 26--305 27--305 ## [28] 28--305 29--305 30--305 31--305 32--305 33--305 34--305 35--305 36--305 ## [37] 37--305 38--305 39--305 40--305 41--305 42--305 43--305 44--305 45--305 ## [46] 46--306 26--306 47--307 48--307 49--308 26--308 50--308 51--309 26--309 ## [55] 52--309 33--309 53--309 54--310 55--312 56--312 57--312 58--312 59--312 ## + ... omitted several edges The syntax for manipulating igraphs is demonstrated below. We use the V() and E() functions to call on either vertices or edges of our igraph, respective. hen can use the $ symbol to subset from those elements of the network. # Subset the vertex attribute: the names of the vertices head(V(g1)$name) ## [1] &quot;Agricultural Coalitions: Landowners membership fees&quot; ## [2] &quot;Anchor QEA&quot; ## [3] &quot;Audubon Canyon Ranch&quot; ## [4] &quot;Bachand and Associates&quot; ## [5] &quot;BTS&quot; ## [6] &quot;CalFish&quot; # Subset the edge attribute: a logical value for whether a collaboration # happened between 1995-2009 head(E(g1)$Y1995_2009) ## [1] TRUE FALSE FALSE FALSE FALSE FALSE 3.2 network Personally, I find that the igraph package has more limited statistical functionality than network package (and its associated statnet suite of packes), so I prefer network objects. We initialize a network object with the network function (network really needs to get more creative in its naming approaches). Just like with igraph, for our one-mode network we will use our projected edges and mode one nodes. For our two-mode network we can use our full edge and node lists. Note: You’ll often see folks converting igraphs to network objects using the intergraph package. library(intergraph) net1_convert &lt;- asNetwork(g1) net1_convert ## Network attributes: ## vertices = 139 ## directed = FALSE ## hyper = FALSE ## loops = FALSE ## multiple = FALSE ## bipartite = FALSE ## total edges= 475 ## missing edges= 0 ## non-missing edges= 475 ## ## Vertex attribute names: ## mode url vertex.names ## ## Edge attribute names: ## before_1980 Y1980_1994 Y1995_2009 Y2010_2024 This conversion function can be very useful, but be sure to double check your work. Right now, with a relatively simple network (undirected and unweighted) the conversion works fine, but in other cases the default settings may require some attention. Because of this, personally I like to generate network objects directly from my edge and node lists. Within the network package we can use the network function and read in our edge lists (as the x argument), vertices, and specify features of the network such as whether or not it is directed or bipartite. net1 &lt;- network(x = edges_1mode, vertices = nodes_1mode, bipartite = F, directed = F) net2 &lt;- network(x = edges_2mode, vertices = nodes_2mode, bipartite = T, directed = F) When we print out a network object we get a different-looking summary, but it generally carries the same information: net1 ## Network attributes: ## vertices = 139 ## directed = FALSE ## hyper = FALSE ## loops = FALSE ## multiple = FALSE ## bipartite = FALSE ## total edges= 475 ## missing edges= 0 ## non-missing edges= 475 ## ## Vertex attribute names: ## mode name url vertex.names ## ## Edge attribute names: ## before_1980 Y1980_1994 Y1995_2009 Y2010_2024 net2 ## Network attributes: ## vertices = 435 ## directed = FALSE ## hyper = FALSE ## loops = FALSE ## multiple = FALSE ## bipartite = 138 ## total edges= 680 ## missing edges= 0 ## non-missing edges= 680 ## ## Vertex attribute names: ## enddate funds id_numeric mgmt_Environmentalconditions mgmt_Floodriskandlandusemanagement mgmt_Governance mgmt_Habitatmanagement mgmt_Invasivenonnativespeciesmanagement mgmt_Nativespeciesmanagement mgmt_Waterquality mgmt_Watersupplymanagement mode n_years name sci_Amphibiansandreptiles sci_Aquaticvegetation sci_Biologicalresourceuse sci_Channelizedhabitats sci_Environmentalconditions sci_Fish sci_Floodplain sci_Foodwebs sci_Habitatchanges sci_Hydrologicchanges sci_Hydrologyandhydrodynamics sci_Invasivenonnativespecies sci_Invertebrates sci_Landuseandhumanactivities sci_Mammals sci_Nutrientsenergyandfoodweb sci_Riparianhabitats sci_Sediment sci_Species sci_Terrestrialhabitats sci_Tidalwetlands sci_Waterquality sci_Weatherandclimate startdate trunc_name url vertex.names ## ## Edge attribute names: ## contribution leadership org_id_numeric project_id_numeric The syntax for manipulating network objects is demonstrated below. We use the %v% and %e% operators to call on either vertices or edges of our network, and then name the attribute in quotation marks tail(net2 %v% &#39;n_years&#39;) ## [1] 3 4 4 4 1 6 head(net1 %e% &#39;Y1995_2009&#39;) ## [1] TRUE FALSE FALSE FALSE FALSE FALSE To save yourself trouble in the long run, it may be best to consider your network type, what kinds of analyses and visualization you’d like to do, and select a network package to stick to for that. Because there are differences in how these objects interact with various network analytical functions and visualization tools, and how they are indexed (V()$ vs %v%), it is worthwhile to stay consistent. "],["plotting-packages.html", "4 Plotting packages 4.1 ggraph 4.2 Other packages and functions", " 4 Plotting packages Let’s load in a few more libraries that we’ll need for plotting 4.1 ggraph For this workshop we will use the ggraph package (and function) for network visualization, created by Thomas Lin Pedersen, who also happens to make ‘generative’ artwork in R. ggraph uses the same approach as the ggplot2 grammar of graphics. This means is has three core components: 1. (network) data, 2. aesthetic mappings, and 3. geometries, in this case edges and nodes. Where this differs from more traditional ggplotting approaches using tabular data (e.g. data frames), network objects have built-in mapping coordinates for nodes and its. Specifically, there are x and y variables for the node data. We can combine the ggraph() function with a geometry specific to networks, geom_node_point(), to see this default setting. ggraph(net1) + geom_node_point() ## Using &quot;stress&quot; as default layout Here we see that the node point geometry uses a default layout based on the ‘stress’ algorithm (more in the following section), plotting the node points as we see above. To connect these point, we can use a ‘edge link’ geometry, geom_edge_link(), which uses the network object’s built in x, y, xend, and yend variables for the edge data. ggraph(net1) + geom_node_point() + geom_edge_link() ## Using &quot;stress&quot; as default layout This will be the foundation what we build on, starting in the next section. 4.2 Other packages and functions There are several plotting packages out there, some of them work with different network objects and requiring different knowledge. Excellent overviews of some of them are provided in this post by Katya Ognyanova. I won’t need to repeat these, but it is worth seeing the basic representation and understanding how igraph vs. network objects look differently in them, by default. 4.2.1 plot() Base R plotting works with network and igraph objects, though their defaults for each object are different. plot(net1) plot(g1) 4.2.2 GGally::ggnet2() The ggnet2 function is also dynamic, but despite being housed as part of the GGally extension of the ggplot2 series it seems to function more like a base R plot. For this function, igraph and network objects look the same. GGally::ggnet2(net1) 4.2.3 ggnetwork Very similar to ggraph and also an extension of the ggplot family is the ggnetwork function. This function integrates directly with ggplot2 and specifies the default coordinates of ggraph, but otherwise operates quite similarly. For this function, igraph and network objects look the same. library(ggplot2) library(ggnetwork) ggplot(net1, aes(x = x, y = y, xend = xend, yend = yend)) + geom_nodes() + geom_edges() "],["one-mode-visualization-1.html", "5 One-mode visualization 5.1 Introduction 5.2 Getting started with ggraph 5.3 Community detection 5.4 Longitudinal networks 5.5 Interactive plots DRAFTING", " 5 One-mode visualization library(dplyr) library(magrittr) library(igraph) library(network) library(sna) library(ggraph) 5.1 Introduction 5.1.1 Visualization goals: How have different organizations collaborated across projects? Do we see any particular research communities emerge across these collaborations? (community detection + representing node attributes by color) How have those collaborations changed over time? (make subgraphs based on edge attribute + make multiple plots with fixed coordinates) 5.1.2 Preparing to work with network We are going to stick to only working with the network package, even though the functions we will use for visualization are compatible with both objects. I propose using network objects because they are compatible with more advanced statistical analysis provided through the statnet suite of packages. igraph objects should also work with the ggraph function, but because the syntax for working with the objects is different, the code used to do that would need to change. Before we move forward with network, it is worth mentioning that there are commonly-used network functions in each package, igraph and network, that mask one another. For instance: sna::degree() igraph::degree() The igraph degree function will work only on igraph objects and sna degree function will work only on network objects. This can create a headache. To avoid confusion and masking in R, we are going to detach the igraph package and work only with network objects and compatible packages like sna. detach(&quot;package:igraph&quot;, unload = TRUE) 5.2 Getting started with ggraph To introduce the basics of the ggraph package, we’re going to focus on our first question: What does the collaborative network of Delta science research look like? As notes in the previous section, ggraph uses the same approach as the ggplot2 grammar of graphics. This means is has three core components: 1. (network) data, 2. geometries, in this case edges and nodes, and 3. aesthetic mappings. As with any ggplot we can add a theme that suits the look of the figure, and ‘void’ themes are often suited for networks. ggraph(net1) + geom_edge_link() + geom_node_point() + theme_void() These are some defaults at play here: layout = ‘auto’, which is the ‘stress’ layout default aesthetic mapping for geom_edges: x, y, xend, yend default aesthetic mapping for geom_node_point: x, y 5.2.1 Layouts First, let’s talk about layouts. Networks are typically laid out based on the algorithm you (or the package default) chooses. These layouts then are a choice, based on how you would like to present the network. Because networks are depicting actors and relationships in an two-dimensional space (x,y), there is no ‘right’ way to plot actors in space (unless, of course, you have actual spatial data associated with your nodes). In which case, you could use an approach like this NETWORK MAP. Instead, many network theorists have developed layout algorithms, which define rules for calculating the x and y coordinates of the nodes. Many layout algorithms aim to represent networks so that strongly connected nodes are plotting in close proximity. There is an overview of some of the different layouts presented in this blog post, and descriptions of some of them in the ggraph vignette and documentation, under the layout_tbl_graph_... functions. Below we present our network with a few different layouts. ggraph(net1, layout = &#39;stress&#39;, bbox = 5) + geom_edge_link() + geom_node_point() + theme_void() + labs(title = &#39;Stress (bbox = 5)&#39;) + theme(plot.title = element_text(hjust = 0.5)) ggraph(net1, layout = &#39;kk&#39;) + geom_edge_link() + geom_node_point() + theme_void() + labs(title = &#39;Kamada and Kawai (spring-based algorithm)&#39;) + theme(plot.title = element_text(hjust = 0.5)) ggraph(net1, layout = &#39;fr&#39;) + geom_edge_link() + geom_node_point() + theme_void() + labs(title = &#39;Fruchterman and Reingold (force-directed algorithm)&#39;) + theme(plot.title = element_text(hjust = 0.5)) ggraph(net1, layout = &#39;circle&#39;) + geom_edge_link() + geom_node_point() + theme_void() + labs(title = &#39;Circle&#39;) + theme(plot.title = element_text(hjust = 0.5)) Note that there is a whole world of plotting networks using different conceptualizations of nodes and edges. These conceptualizations of nodes and edges may relate to the For the sake of this workshop we are sticking to more ‘traditional’ network visualization in that we will stay firmly rooted in nodes depicted as points and edges depicted as line. You can also set a manual layout. Because layouts are just x and y coordinates of points defined by a certain algorithm. You can extract those coordinates using the create_layout() function from ggraph, and manipulate those coordinates, if need be. We will deal with this more shortly. fixed_coord &lt;- create_layout(net1, layout = &#39;fr&#39;) head(fixed_coord[c(1:3,5)]) ## x y mode ## 1 9.3774426 1.3216426 1 ## 2 -1.9741400 -0.3842824 1 ## 3 4.4038157 -7.5550868 1 ## 4 -7.2411254 -0.8707652 1 ## 5 9.0236846 4.0631985 1 ## 6 -0.3980371 -8.9681281 1 ## name ## 1 Agricultural Coalitions: Landowners membership fees ## 2 Anchor QEA ## 3 Audubon Canyon Ranch ## 4 Bachand and Associates ## 5 BTS ## 6 CalFish For our one-mode networks, we are going to use the ‘fr’ layout, which is the Fruchterman and Reingold (force-directed algorithm). This is a choice that helps place higher-degree nodes in the center, and low-degree and isolate nodes on the periphery. 5.2.2 Aesthetics Now that we’ve chosen a layout, let’s start adding some aesthetic features. This process will look very much like aesthetic mapping in ggplot2: we can assign aesthetics like color, size, shape, etc. to both our edge and node geometries. We can assign those features from the data directly, or just as stand-alone features. Size by degree: Let’s first say that we’d like to size our nodes by their degree centrality. While more central nodes are already places at the center of our layout’s algorithm, it can be helpful to also increase their size to communicate this point. To size by degree, we will want to create a degree variable are a node attribute using the degree function. net1 %v% &#39;degree&#39; &lt;- sna::degree(net1) Color-blind friendly colors: We’d also like our nodes and edges to be colored differently than the default black, so we can set these colors to our geometries. Because the focus of these networks are on nodes, not edges, we can set our edges to a less pronounced color like grey, and select a color-blind friendly color palette to select a node color from. I personally like to use viridis: viridis::viridis(12) ## [1] &quot;#440154FF&quot; &quot;#482173FF&quot; &quot;#433E85FF&quot; &quot;#38598CFF&quot; &quot;#2D708EFF&quot; &quot;#25858EFF&quot; ## [7] &quot;#1E9B8AFF&quot; &quot;#2BB07FFF&quot; &quot;#51C56AFF&quot; &quot;#85D54AFF&quot; &quot;#C2DF23FF&quot; &quot;#FDE725FF&quot; The latest version of R studio lets us see these colors when we write them out in a script, so let’s do that, and assign these colors to an object named clrs. We will be referencing this vector as we start using the palette. clrs &lt;- c(&quot;#440154FF&quot;, &quot;#482173FF&quot;, &quot;#433E85FF&quot;, &quot;#38598CFF&quot;, &quot;#2D708EFF&quot;, &quot;#25858EFF&quot;, &quot;#1E9B8AFF&quot;, &quot;#2BB07FFF&quot;, &quot;#51C56AFF&quot;, &quot;#85D54AFF&quot;, &quot;#C2DF23FF&quot;, &quot;#FDE725FF&quot;) We can now integrate these three features: node size, edge color, and node color, into our plot. Let’s also add an alpha for the edges there. ggraph(net1, layout = &#39;fr&#39;) + geom_edge_link(color = &quot;gray70&quot;) + geom_node_point(aes(size = net1 %v% &#39;degree&#39;), color = clrs[4]) Note: There is also some compatibility with tidyverse’s graph function, tidygraph, but we will not really be exploring that today. ggraph(net1, layout = &#39;fr&#39;) + geom_edge_link(color = &quot;gray70&quot;) + geom_node_point(aes(size = tidygraph::centrality_degree()), color = clrs[4]) We can also add themes and labels, just like with ggplot2. theme_void() is great for networks because it removes any coordinates or background color. ggraph(net1, layout = &#39;fr&#39;) + geom_edge_link(color = &quot;gray70&quot;, alpha = .5) + geom_node_point(aes(size = net1 %v% &#39;degree&#39;), color = clrs[4], alpha = .7) + theme_void() + theme(legend.position = &quot;none&quot;) + labs(title = &quot;Delta Science Collaborative Research Network&quot;) Notice it changes every time, a little bit. You can set your seed (every time before you plot to keep it consistent.) 5.2.3 Node labels So far we are getting a clear shape of the network. But our main goal is to understand who is central to collaboration. Let’s try to add some node text with geom_node_text(). We have a variable that is the name of our vertices: head(net1 %v% &#39;name&#39;) ## [1] &quot;Agricultural Coalitions: Landowners membership fees&quot; ## [2] &quot;Anchor QEA&quot; ## [3] &quot;Audubon Canyon Ranch&quot; ## [4] &quot;Bachand and Associates&quot; ## [5] &quot;BTS&quot; ## [6] &quot;CalFish&quot; Let’s add this as a text geometry. ggraph(net1, layout = &#39;fr&#39;) + geom_edge_link(color = &quot;gray70&quot;, alpha = 0.5) + geom_node_point(aes(size = net1 %v% &#39;degree&#39;), color = clrs[4], alpha = .7) + theme_void() + theme_void() + theme(legend.position = &quot;none&quot;) + labs(title = &quot;Delta Science Collaborative Research Network&quot;) + geom_node_text(aes(label = net1 %v% &#39;name&#39;), size = 3, color=&quot;black&quot;) Okay, a bit overwhelming. Instead, let’s be selective based on degree. Let’s say we want to take the top 5-degree nodes and label them. topdeg &lt;- data.frame(&quot;deg&quot; = net1 %v% &#39;degree&#39;) %&gt;% top_n(5) net1 %v% &#39;labels&#39; &lt;- ifelse((net1 %v% &#39;degree&#39;) %in% topdeg$deg, net1 %v% &#39;name&#39;, &#39;&#39;) Now we have a sparse label attribute. net1 %v% &#39;labels&#39; ## [1] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;CDFW&quot; &quot;&quot; ## [10] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;DWR&quot; &quot;&quot; &quot;&quot; &quot;&quot; ## [19] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ## [28] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ## [37] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ## [46] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ## [55] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ## [64] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ## [73] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ## [82] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ## [91] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ## [100] &quot;&quot; &quot;&quot; &quot;USBR&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ## [109] &quot;&quot; &quot;&quot; &quot;USFWS&quot; &quot;&quot; &quot;USGS&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ## [118] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ## [127] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ## [136] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; We can use this labels aesthetic to make our figure more easily readable. ggraph(net1, layout = &#39;fr&#39;) + geom_edge_link(color = &quot;gray70&quot;, alpha = 0.5) + geom_node_point(aes(size = net1 %v% &#39;degree&#39;), color = clrs[4], alpha = .7) + theme_void() + theme(legend.position = &quot;none&quot;) + labs(title = &quot;Delta Science Collaborative Research Network&quot;) + geom_node_text(aes(label = net1 %v% &#39;labels&#39;), size = 3, color=&quot;black&quot;) Almost. Let’s include a repel = T argument to make sure the text doesn’t overlap. ggraph(net1, layout = &#39;fr&#39;) + geom_edge_link(color = &quot;gray70&quot;, alpha = 0.5) + geom_node_point(aes(size = net1 %v% &#39;degree&#39;), color = clrs[4], alpha = .7) + theme_void() + theme(legend.position = &quot;none&quot;) + labs(title = &quot;Delta Science Collaborative Research Network&quot;) + geom_node_text(aes(label = net1 %v% &#39;labels&#39;), size = 3, color=&quot;black&quot;, repel = T) Now that we’ve got that down as a base, I want to set this as a function so that we can move through other material a little more smoothly. netplot_function &lt;- function(netname){ p &lt;- ggraph(netname, layout = &#39;fr&#39;) + geom_edge_link(color = &quot;gray70&quot;, alpha = 0.5) + geom_node_point(aes(size = netname %v% &#39;degree&#39;), color = clrs[4], alpha = .7) + theme_void() + theme(legend.position = &quot;none&quot;) + geom_node_text(aes(label = netname %v% &#39;labels&#39;), size = 3, color=&quot;black&quot;, repel = T) return(p) } 5.2.4 Removing isolates Before we move too far along in our formatting of this figure, we may want to remove isolates. There are certainly occasions where we want to see isolates in our network, but other times we are interested in the main component. We can identify our isolates and then induce our subgraph with only the non-isolate nodes using the get.inducedSubgraph() function. isolates(net1) ## [1] 5 6 10 14 16 18 26 33 37 42 46 50 56 58 69 76 77 79 97 ## [20] 106 108 115 117 127 131 134 137 noiso &lt;- (1:network.size(net1))[-isolates(net1)] net1_noiso &lt;- get.inducedSubgraph(net1, noiso) Now we can see our network without isolates. netplot_function(net1_noiso) 5.3 Community detection Moving on to a deeper look at the network. Often we’re curious about whether or not there is some pattern within our network. Are some organizations linking with certain others on a more regular basis? Is there a grouping trend in our network that we can’t see without some kind of visual aid? To answer this, we might want to do some community detection approaches. 5.3.1 Community is broadly defined Broadly, community detection is… Have there been certain communities of research over time? While we’ve moved away from igraph, I do want to point out that it has a number of community detection algorithms. ?igraph::cluster_walktrap() ?igraph::cluster_leiden() ?igraph::cluster_optimal() In the sna package there is the equivalence cluster (equiv.cluster) function. ?sna::equiv.clust() 5.3.2 Equivalence clusters Equivalence clustering is a clustering method which groups nodes based on distance from one another. You can specify what kinds of clustering method to use with the cluster.method argument and what distance function to use with equiv.fun, but it by default uses a hierarchical clustering method based on structural equivalence using Hamming distance. We can calculate the distance and plot a dendrogram of the clusters. ec &lt;- equiv.clust(net1_noiso) plot(ec) We can look at the different ‘heights’ of the nodes within the dendrogram, and see how many different levels there are. length(unique(ec$cluster$height)) ## [1] 30 Now that we have these clusters, we can turn to another method, blockmodelling, which will evaluate blocks of groupings of nodes. We can specify how may blocks we want (k), or specify a height at which to split the classes (h). The block model output is a matrix with density measures (this is the default of the function). bm &lt;- blockmodel(net1_noiso, ec, k = 30, glabels = &quot;DSC Collaboration&quot;) bm$block.model ## Block 1 Block 2 Block 3 Block 4 Block 5 Block 6 ## Block 1 0.010628019 0.003623188 0.1521739 0.007246377 0.04347826 0.2173913 ## Block 2 0.003623188 0.666666667 0.0000000 0.000000000 0.00000000 0.0000000 ## Block 3 0.152173913 0.000000000 NaN 1.000000000 1.00000000 1.0000000 ## Block 4 0.007246377 0.000000000 1.0000000 0.666666667 0.66666667 0.6666667 ## Block 5 0.043478261 0.000000000 1.0000000 0.666666667 NaN 1.0000000 ## Block 6 0.217391304 0.000000000 1.0000000 0.666666667 1.00000000 NaN ## Block 7 0.010869565 0.000000000 1.0000000 0.000000000 0.00000000 1.0000000 ## Block 8 0.007246377 0.000000000 0.3333333 0.000000000 0.33333333 0.3333333 ## Block 9 0.000000000 0.000000000 1.0000000 0.000000000 0.00000000 0.6666667 ## Block 10 0.003623188 0.027777778 0.8333333 0.000000000 0.00000000 0.0000000 ## Block 11 0.065217391 0.000000000 1.0000000 0.666666667 1.00000000 1.0000000 ## Block 12 0.000000000 0.000000000 0.0000000 0.000000000 0.00000000 0.0000000 ## Block 13 0.000000000 0.000000000 0.0000000 0.000000000 0.00000000 0.0000000 ## Block 14 0.005434783 0.166666667 1.0000000 0.000000000 0.00000000 0.0000000 ## Block 15 0.000000000 0.000000000 0.0000000 0.000000000 0.00000000 0.0000000 ## Block 16 0.086956522 0.000000000 1.0000000 0.000000000 0.00000000 1.0000000 ## Block 17 0.130434783 0.000000000 1.0000000 0.000000000 1.00000000 1.0000000 ## Block 18 0.000000000 0.000000000 1.0000000 0.000000000 0.00000000 1.0000000 ## Block 19 0.000000000 0.000000000 0.0000000 0.000000000 1.00000000 0.0000000 ## Block 20 0.173913043 0.500000000 1.0000000 0.000000000 0.00000000 1.0000000 ## Block 21 0.065217391 0.000000000 0.0000000 0.000000000 1.00000000 1.0000000 ## Block 22 0.021739130 0.500000000 1.0000000 0.000000000 0.00000000 1.0000000 ## Block 23 0.065217391 0.000000000 1.0000000 0.000000000 0.00000000 1.0000000 ## Block 24 0.000000000 0.000000000 0.5000000 0.000000000 0.00000000 0.0000000 ## Block 25 0.108695652 0.000000000 1.0000000 0.000000000 0.00000000 1.0000000 ## Block 26 0.065217391 0.000000000 1.0000000 0.000000000 1.00000000 0.0000000 ## Block 27 0.043478261 0.000000000 1.0000000 0.666666667 0.00000000 1.0000000 ## Block 28 0.130434783 0.000000000 1.0000000 0.666666667 0.00000000 1.0000000 ## Block 29 0.217391304 0.333333333 1.0000000 0.333333333 0.00000000 1.0000000 ## Block 30 0.130434783 0.166666667 1.0000000 0.666666667 1.00000000 1.0000000 ## Block 7 Block 8 Block 9 Block 10 Block 11 Block 12 ## Block 1 0.01086957 0.007246377 0.0000000 0.003623188 0.06521739 0.0 ## Block 2 0.00000000 0.000000000 0.0000000 0.027777778 0.00000000 0.0 ## Block 3 1.00000000 0.333333333 1.0000000 0.833333333 1.00000000 0.0 ## Block 4 0.00000000 0.000000000 0.0000000 0.000000000 0.66666667 0.0 ## Block 5 0.00000000 0.333333333 0.0000000 0.000000000 1.00000000 0.0 ## Block 6 1.00000000 0.333333333 0.6666667 0.000000000 1.00000000 0.0 ## Block 7 0.50000000 0.000000000 0.0000000 0.000000000 1.00000000 0.0 ## Block 8 0.00000000 1.000000000 0.0000000 0.000000000 0.00000000 0.0 ## Block 9 0.00000000 0.000000000 0.3333333 0.000000000 0.33333333 0.0 ## Block 10 0.00000000 0.000000000 0.0000000 0.466666667 0.33333333 0.0 ## Block 11 1.00000000 0.000000000 0.3333333 0.333333333 NaN 0.0 ## Block 12 0.00000000 0.000000000 0.0000000 0.000000000 0.00000000 0.8 ## Block 13 0.00000000 0.083333333 0.0000000 0.000000000 0.00000000 0.0 ## Block 14 0.00000000 0.000000000 0.0000000 0.000000000 0.00000000 0.0 ## Block 15 0.00000000 0.000000000 0.0000000 0.000000000 0.00000000 0.0 ## Block 16 1.00000000 0.000000000 0.0000000 0.000000000 1.00000000 0.0 ## Block 17 0.00000000 0.333333333 0.0000000 0.000000000 1.00000000 0.0 ## Block 18 0.00000000 1.000000000 1.0000000 0.000000000 1.00000000 0.0 ## Block 19 0.25000000 0.000000000 0.3333333 0.000000000 1.00000000 0.0 ## Block 20 0.25000000 0.000000000 0.3333333 0.500000000 1.00000000 0.0 ## Block 21 0.25000000 0.000000000 0.0000000 0.000000000 0.00000000 0.0 ## Block 22 0.00000000 1.000000000 1.0000000 0.000000000 0.00000000 0.0 ## Block 23 1.00000000 0.333333333 1.0000000 0.000000000 1.00000000 0.0 ## Block 24 0.00000000 0.000000000 0.0000000 0.000000000 0.00000000 0.0 ## Block 25 0.50000000 0.000000000 0.6666667 0.000000000 1.00000000 0.0 ## Block 26 0.00000000 0.333333333 0.3333333 0.000000000 0.00000000 0.0 ## Block 27 1.00000000 0.000000000 0.0000000 0.000000000 1.00000000 0.0 ## Block 28 1.00000000 0.000000000 1.0000000 0.000000000 1.00000000 0.0 ## Block 29 0.50000000 1.000000000 1.0000000 0.500000000 1.00000000 0.6 ## Block 30 0.00000000 0.000000000 0.0000000 0.000000000 1.00000000 0.6 ## Block 13 Block 14 Block 15 Block 16 Block 17 Block 18 ## Block 1 0.00000000 0.005434783 0 0.08695652 0.1304348 0.0 ## Block 2 0.00000000 0.166666667 0 0.00000000 0.0000000 0.0 ## Block 3 0.00000000 1.000000000 0 1.00000000 1.0000000 1.0 ## Block 4 0.00000000 0.000000000 0 0.00000000 0.0000000 0.0 ## Block 5 0.00000000 0.000000000 0 0.00000000 1.0000000 0.0 ## Block 6 0.00000000 0.000000000 0 1.00000000 1.0000000 1.0 ## Block 7 0.00000000 0.000000000 0 1.00000000 0.0000000 0.0 ## Block 8 0.08333333 0.000000000 0 0.00000000 0.3333333 1.0 ## Block 9 0.00000000 0.000000000 0 0.00000000 0.0000000 1.0 ## Block 10 0.00000000 0.000000000 0 0.00000000 0.0000000 0.0 ## Block 11 0.00000000 0.000000000 0 1.00000000 1.0000000 1.0 ## Block 12 0.00000000 0.000000000 0 0.00000000 0.0000000 0.0 ## Block 13 0.66666667 0.000000000 0 0.00000000 0.2500000 0.0 ## Block 14 0.00000000 1.000000000 0 0.00000000 0.0000000 0.0 ## Block 15 0.00000000 0.000000000 1 0.00000000 1.0000000 0.0 ## Block 16 0.00000000 0.000000000 0 NaN 0.0000000 0.0 ## Block 17 0.25000000 0.000000000 1 0.00000000 NaN 0.0 ## Block 18 0.00000000 0.000000000 0 0.00000000 0.0000000 NaN ## Block 19 0.00000000 0.000000000 0 0.00000000 0.0000000 1.0 ## Block 20 0.00000000 0.250000000 0 0.00000000 0.0000000 1.0 ## Block 21 0.00000000 0.250000000 0 0.00000000 1.0000000 0.0 ## Block 22 0.75000000 0.000000000 0 0.00000000 0.0000000 1.0 ## Block 23 0.00000000 0.000000000 0 1.00000000 1.0000000 1.0 ## Block 24 0.12500000 0.000000000 0 0.00000000 0.0000000 0.5 ## Block 25 0.00000000 1.000000000 1 1.00000000 1.0000000 1.0 ## Block 26 0.00000000 0.000000000 1 0.00000000 1.0000000 1.0 ## Block 27 0.50000000 0.000000000 1 1.00000000 1.0000000 0.0 ## Block 28 1.00000000 0.250000000 1 1.00000000 1.0000000 1.0 ## Block 29 0.50000000 0.500000000 1 1.00000000 1.0000000 1.0 ## Block 30 0.00000000 1.000000000 0 1.00000000 0.0000000 0.0 ## Block 19 Block 20 Block 21 Block 22 Block 23 Block 24 ## Block 1 0.0000000 0.1739130 0.06521739 0.02173913 0.06521739 0.000 ## Block 2 0.0000000 0.5000000 0.00000000 0.50000000 0.00000000 0.000 ## Block 3 0.0000000 1.0000000 0.00000000 1.00000000 1.00000000 0.500 ## Block 4 0.0000000 0.0000000 0.00000000 0.00000000 0.00000000 0.000 ## Block 5 1.0000000 0.0000000 1.00000000 0.00000000 0.00000000 0.000 ## Block 6 0.0000000 1.0000000 1.00000000 1.00000000 1.00000000 0.000 ## Block 7 0.2500000 0.2500000 0.25000000 0.00000000 1.00000000 0.000 ## Block 8 0.0000000 0.0000000 0.00000000 1.00000000 0.33333333 0.000 ## Block 9 0.3333333 0.3333333 0.00000000 1.00000000 1.00000000 0.000 ## Block 10 0.0000000 0.5000000 0.00000000 0.00000000 0.00000000 0.000 ## Block 11 1.0000000 1.0000000 0.00000000 0.00000000 1.00000000 0.000 ## Block 12 0.0000000 0.0000000 0.00000000 0.00000000 0.00000000 0.000 ## Block 13 0.0000000 0.0000000 0.00000000 0.75000000 0.00000000 0.125 ## Block 14 0.0000000 0.2500000 0.25000000 0.00000000 0.00000000 0.000 ## Block 15 0.0000000 0.0000000 0.00000000 0.00000000 0.00000000 0.000 ## Block 16 0.0000000 0.0000000 0.00000000 0.00000000 1.00000000 0.000 ## Block 17 0.0000000 0.0000000 1.00000000 0.00000000 1.00000000 0.000 ## Block 18 1.0000000 1.0000000 0.00000000 1.00000000 1.00000000 0.500 ## Block 19 NaN 1.0000000 0.00000000 0.00000000 0.00000000 0.000 ## Block 20 1.0000000 NaN 1.00000000 1.00000000 1.00000000 0.000 ## Block 21 0.0000000 1.0000000 NaN 0.00000000 0.00000000 0.000 ## Block 22 0.0000000 1.0000000 0.00000000 NaN 1.00000000 0.000 ## Block 23 0.0000000 1.0000000 0.00000000 1.00000000 NaN 0.000 ## Block 24 0.0000000 0.0000000 0.00000000 0.00000000 0.00000000 1.000 ## Block 25 0.0000000 1.0000000 0.00000000 1.00000000 1.00000000 0.500 ## Block 26 1.0000000 0.0000000 0.00000000 1.00000000 1.00000000 1.000 ## Block 27 0.0000000 1.0000000 0.00000000 0.00000000 1.00000000 0.250 ## Block 28 1.0000000 1.0000000 1.00000000 1.00000000 1.00000000 0.500 ## Block 29 0.0000000 1.0000000 1.00000000 1.00000000 1.00000000 0.500 ## Block 30 1.0000000 1.0000000 0.00000000 0.00000000 0.00000000 0.000 ## Block 25 Block 26 Block 27 Block 28 Block 29 Block 30 ## Block 1 0.1086957 0.06521739 0.04347826 0.1304348 0.2173913 0.1304348 ## Block 2 0.0000000 0.00000000 0.00000000 0.0000000 0.3333333 0.1666667 ## Block 3 1.0000000 1.00000000 1.00000000 1.0000000 1.0000000 1.0000000 ## Block 4 0.0000000 0.00000000 0.66666667 0.6666667 0.3333333 0.6666667 ## Block 5 0.0000000 1.00000000 0.00000000 0.0000000 0.0000000 1.0000000 ## Block 6 1.0000000 0.00000000 1.00000000 1.0000000 1.0000000 1.0000000 ## Block 7 0.5000000 0.00000000 1.00000000 1.0000000 0.5000000 0.0000000 ## Block 8 0.0000000 0.33333333 0.00000000 0.0000000 1.0000000 0.0000000 ## Block 9 0.6666667 0.33333333 0.00000000 1.0000000 1.0000000 0.0000000 ## Block 10 0.0000000 0.00000000 0.00000000 0.0000000 0.5000000 0.0000000 ## Block 11 1.0000000 0.00000000 1.00000000 1.0000000 1.0000000 1.0000000 ## Block 12 0.0000000 0.00000000 0.00000000 0.0000000 0.6000000 0.6000000 ## Block 13 0.0000000 0.00000000 0.50000000 1.0000000 0.5000000 0.0000000 ## Block 14 1.0000000 0.00000000 0.00000000 0.2500000 0.5000000 1.0000000 ## Block 15 1.0000000 1.00000000 1.00000000 1.0000000 1.0000000 0.0000000 ## Block 16 1.0000000 0.00000000 1.00000000 1.0000000 1.0000000 1.0000000 ## Block 17 1.0000000 1.00000000 1.00000000 1.0000000 1.0000000 0.0000000 ## Block 18 1.0000000 1.00000000 0.00000000 1.0000000 1.0000000 0.0000000 ## Block 19 0.0000000 1.00000000 0.00000000 1.0000000 0.0000000 1.0000000 ## Block 20 1.0000000 0.00000000 1.00000000 1.0000000 1.0000000 1.0000000 ## Block 21 0.0000000 0.00000000 0.00000000 1.0000000 1.0000000 0.0000000 ## Block 22 1.0000000 1.00000000 0.00000000 1.0000000 1.0000000 0.0000000 ## Block 23 1.0000000 1.00000000 1.00000000 1.0000000 1.0000000 0.0000000 ## Block 24 0.5000000 1.00000000 0.25000000 0.5000000 0.5000000 0.0000000 ## Block 25 NaN 1.00000000 1.00000000 1.0000000 1.0000000 1.0000000 ## Block 26 1.0000000 NaN 1.00000000 1.0000000 1.0000000 1.0000000 ## Block 27 1.0000000 1.00000000 NaN 1.0000000 1.0000000 0.0000000 ## Block 28 1.0000000 1.00000000 1.00000000 NaN 1.0000000 1.0000000 ## Block 29 1.0000000 1.00000000 1.00000000 1.0000000 NaN 1.0000000 ## Block 30 1.0000000 1.00000000 0.00000000 1.0000000 1.0000000 NaN membership &lt;- data.frame(&quot;block&quot; = bm$block.membership, &quot;id&quot; = ec$cluster$order) membership &lt;- membership[order(membership$id),] net1_noiso %v% &#39;membership&#39; &lt;- membership$block table(net1_noiso %v% &#39;membership&#39;) ## ## 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ## 46 6 1 3 1 1 4 3 3 6 1 5 4 4 6 1 1 1 1 1 1 1 1 4 1 1 ## 27 28 29 30 ## 1 1 1 1 We could assign color to that membership… but some of those memberships may be more or less meaningful. ggraph(net1_noiso, layout = &#39;fr&#39;) + geom_edge_link(width = 0.5, alpha = 0.5, color = &quot;gray70&quot;) + geom_node_point(aes(size = net1_noiso %v% &#39;degree&#39;, color = factor(net1_noiso %v% &#39;membership&#39;))) + theme_void() + geom_node_text(aes(label = net1_noiso %v% &#39;labels&#39;), size = 3, color=&quot;black&quot;, repel = T) + scale_color_viridis_d() + labs(color = &quot;Community&quot;, size = &quot;Degree&quot;) One way to address this is to consider a threshold for the density values of each block to identify blocks that are more dense than the whole network (see Slide 92). The density of our network is: gden(net1_noiso) ## [1] 0.0764157 So we can use this as a threshold. dense_blocks &lt;- data.frame(&#39;density&#39; = diag(bm$block.model), &#39;b&#39; = 1:length(unique(net1_noiso %v% &#39;membership&#39;))) %&gt;% filter(!(is.nan(density)) &amp; density &gt; gden(net1_noiso)) net1_noiso %v% &#39;member_grp&#39; &lt;- ifelse(net1_noiso %v% &#39;membership&#39; == dense_blocks$b[1], 1, ifelse(net1_noiso %v% &#39;membership&#39; == dense_blocks$b[2], 2, ifelse(net1_noiso %v% &#39;membership&#39; == dense_blocks$b[3], 3, ifelse(net1_noiso %v% &#39;membership&#39; == dense_blocks$b[4], 4, ifelse(net1_noiso %v% &#39;membership&#39; == dense_blocks$b[5], 5, ifelse(net1_noiso %v% &#39;membership&#39; == dense_blocks$b[6], 6, ifelse(net1_noiso %v% &#39;membership&#39; == dense_blocks$b[7], 7, ifelse(net1_noiso %v% &#39;membership&#39; == dense_blocks$b[8], 8, ifelse(net1_noiso %v% &#39;membership&#39; == dense_blocks$b[9], 9, ifelse(net1_noiso %v% &#39;membership&#39; == dense_blocks$b[10], 10, ifelse(net1_noiso %v% &#39;membership&#39; == dense_blocks$b[11], 11, 12))))))))))) Now we can use the ‘member_grp’ node attribute, which associated large and correlated blocks with colors, as our color aesthetic. What we can see is that the most active, central actors like USGS, USFWS, etc., are not in highly dense blocks. Instead, they must work in low density, broader networks in which they span multiple, less connected groups. ggraph(net1_noiso, layout = &#39;fr&#39;) + geom_edge_link(width = 0.5, alpha = 0.5, color = &quot;gray70&quot;) + geom_node_point(aes(size = net1_noiso %v% &#39;degree&#39;, color = factor(net1_noiso %v% &#39;member_grp&#39;))) + theme_void() + geom_node_text(aes(label = net1_noiso %v% &#39;labels&#39;), size = 3, color=&quot;black&quot;, repel = T) + theme(legend.position = &quot;none&quot;) + scale_color_manual(values = c(clrs[1:11], &quot;grey&quot;)) 5.4 Longitudinal networks Often you will want to induce subnetworks – based on edge attribute 5.4.1 Induce subgraphs by edge net1 %v% &#39;id&#39; &lt;- net1 %v% &#39;vertex.names&#39; # Get the edges for each time period t1 &lt;- which(net1 %e% &#39;before_1980&#39; == T) t2 &lt;- which(net1 %e% &#39;Y1980_1994&#39; == T) t3 &lt;- which(net1 %e% &#39;Y1995_2009&#39; == T) t4 &lt;- which(net1 %e% &#39;Y2010_2024&#39; == T) # Induce subgraphs based on those edges net1_t1 &lt;- network::get.inducedSubgraph(net1, eid = t1) net1_t2 &lt;- network::get.inducedSubgraph(net1, eid = t2) net1_t3 &lt;- network::get.inducedSubgraph(net1, eid = t3) net1_t4 &lt;- network::get.inducedSubgraph(net1, eid = t4) Now we have subgraphs net1_t4 ## Network attributes: ## vertices = 60 ## directed = FALSE ## hyper = FALSE ## loops = FALSE ## multiple = FALSE ## bipartite = FALSE ## total edges= 157 ## missing edges= 0 ## non-missing edges= 157 ## ## Vertex attribute names: ## degree id labels mode name url vertex.names ## ## Edge attribute names: ## before_1980 Y1980_1994 Y1995_2009 Y2010_2024 But note that our attributes remain from the whole network (net1_t1 %v% &#39;degree&#39;)[(net1_t1 %v% &#39;name&#39; == &quot;SFEI&quot;)] ## [1] 60 (net1_t2 %v% &#39;degree&#39;)[(net1_t2 %v% &#39;name&#39; == &quot;SFEI&quot;)] ## [1] 60 But this is incorrect, so we want to reassign those values net1_t1 %v% &#39;degree&#39; &lt;- sna::degree(net1_t1) net1_t2 %v% &#39;degree&#39; &lt;- sna::degree(net1_t2) net1_t3 %v% &#39;degree&#39; &lt;- sna::degree(net1_t3) net1_t4 %v% &#39;degree&#39; &lt;- sna::degree(net1_t4) Since our degree value has changed, we also wanted to change our labels. We can write a function to do that get_top_degree &lt;- function(netname, n){ topdeg &lt;- data.frame(&quot;deg&quot; = netname %v% &#39;degree&#39;) %&gt;% top_n(n) labels &lt;- ifelse((netname %v% &#39;degree&#39;) %in% topdeg$deg, netname %v% &#39;name&#39;, &#39;&#39;) return(labels) } net1_t1 %v% &#39;labels&#39; &lt;- get_top_degree(net1_t1, 5) net1_t2 %v% &#39;labels&#39; &lt;- get_top_degree(net1_t2, 5) net1_t3 %v% &#39;labels&#39; &lt;- get_top_degree(net1_t3, 5) net1_t4 %v% &#39;labels&#39; &lt;- get_top_degree(net1_t4, 5) Now let’s plot one of our subgraphs. We can use the same netplot function netplot_function(net1_t1) netplot_function(net1_t2) netplot_function(net1_t3) netplot_function(net1_t4) The issue here is that it is hard to really visualize change because the layout changes every time to make the visualize look more like a network… So let’s fixing our coordinates. We want nodes to be in the same position in the plotting of every subgraph. 5.4.2 Fixing coordinates With ggraph/network, we can fix coordinates by creating a layout table from our initial network. First let’s make sure we have unique identifiers as that table. These layout tables give x and y coordinates to each fixed_coord &lt;- create_layout(net1, layout = &#39;fr&#39;) With these coordinates fixed from our full plot, we can then apply those same coordinates for each subgraph. # create a layout table for the subgraph fixed_coord_t1 &lt;- create_layout(net1_t1, layout = &#39;fr&#39;) # subset the relevant coordinates from the full layout table coords_we_need &lt;- fixed_coord[fixed_coord$id %in% fixed_coord_t1$id, c(1,2,6)] fixed_coord_t1$x &lt;- coords_we_need$x fixed_coord_t1$y &lt;- coords_we_need$y fixed_coord_t1 %&gt;% ggraph() + geom_edge_link(width = 0.5, alpha = 0.5, color = &quot;gray70&quot;) + geom_node_point(aes(size = degree), color = clrs[6]) + theme_void() + theme(legend.position = &quot;none&quot;) + geom_node_text(aes(label = labels), family = &quot;Times&quot;, size = 3, color=&quot;black&quot;) + xlim(c(-9, 7)) + ylim(c(-7, 8)) subplot_viz_fixed &lt;- function(fixed_coords, netname){ fixed_coord_t &lt;- create_layout(netname, layout = &#39;fr&#39;) coords_we_need &lt;- fixed_coord[fixed_coord$id %in% fixed_coord_t$id, c(1,2,6)] fixed_coord_t$x &lt;- coords_we_need$x fixed_coord_t$y &lt;- coords_we_need$y fixed_coord_t %&gt;% ggraph() + geom_edge_link(width = 0.5, alpha = 0.5, color = &quot;gray70&quot;) + geom_node_point(aes(size = degree), color = clrs[4]) + theme_void() + theme(legend.position = &quot;none&quot;) + geom_node_text(aes(label = labels), family = &quot;Times&quot;, size = 3, color=&quot;black&quot;) + xlim(c(-9, 7)) + ylim(c(-7, 8)) } subplot_viz_fixed(fixed_coord, net1) subplot_viz_fixed(fixed_coord, net1_t1) subplot_viz_fixed(fixed_coord, net1_t2) subplot_viz_fixed(fixed_coord, net1_t3) subplot_viz_fixed(fixed_coord, net1_t4) subplot_viz_fixed(fixed_coord, net1) + labs(title = &quot;Collaborative network: 1950-2022&quot;) + theme(text= element_text(size=10, family=&quot;Times&quot;)) subplot_viz_fixed(fixed_coord, net1_t1) + labs(title = &quot;Collaborative network: 1950-1979&quot;) + theme(text= element_text(size=10, family=&quot;Times&quot;)) subplot_viz_fixed(fixed_coord, net1_t2) + labs(title = &quot;Collaborative network: 1980-1994&quot;) + theme(text= element_text(size=10, family=&quot;Times&quot;)) subplot_viz_fixed(fixed_coord, net1_t3) + labs(title = &quot;Collaborative network: 1995-2009&quot;) + theme(text= element_text(size=10, family=&quot;Times&quot;)) subplot_viz_fixed(fixed_coord, net1_t4) + labs(title = &quot;Collaborative network: 2010-2022&quot;) + theme(text= element_text(size=10, family=&quot;Times&quot;)) 5.5 Interactive plots DRAFTING p1 &lt;- subplot_viz_fixed(fixed_coord, net1) + labs(title = &quot;Collaborative network: 1950-2022&quot;) + theme(text= element_text(size=10, family=&quot;Times&quot;)) plotly::ggplotly(p1) D3 "],["two-mode-visualization-1.html", "6 Two-mode visualization 6.1 Normalized degree for both modes… (see Ebba) 6.2 Leaders versus contributors? 6.3 Climate projects", " 6 Two-mode visualization What actors have been most active across projects? Are most-active members typically leaders or contributors? (make subgraphs based on edge attribute + make multiple plots with fixed coordinates) What actors have been most active on climate-related projects? (Node attribute of project node) We can use the same approaches as with one mode… but we shouldn’t because mode one and two are just not comparable. net2 %v% &#39;degree&#39; &lt;- sna::degree(net2) topdeg &lt;- data.frame(&quot;deg&quot; = net2 %v% &#39;degree&#39;) %&gt;% top_n(5) net2 %v% &#39;labels&#39; &lt;- ifelse((net2 %v% &#39;degree&#39;) %in% topdeg$deg, net2 %v% &#39;name&#39;, &#39;&#39;) netplot_function(net2) net2 %v% &#39;mode&#39; ## [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ## [38] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ## [75] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ## [112] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 ## [149] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [186] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [223] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [260] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [297] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [334] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [371] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [408] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ggraph(net2, layout = &#39;fr&#39;) + geom_edge_link(width = 0.5, alpha = 0.5, color = &quot;gray70&quot;) + geom_node_point(aes(size = net2 %v% &#39;degree&#39;, shape = factor(net2 %v% &#39;mode&#39;), color = factor(net2 %v% &#39;mode&#39;))) + theme_void() + scale_color_viridis_d() + geom_node_text(aes(label = net2 %v% &#39;labels&#39;), size = 3, color=&quot;black&quot;) + labs(size = &quot;Degree&quot;, color = &quot;Mode&quot;, shape = &quot;Mode&quot;) 6.1 Normalized degree for both modes… (see Ebba) # NORMALIZED degrees and label net2 %v% &#39;degree_norm&#39; &lt;- sna::degree(net2, rescale = T) # make a table, project id as rows and org id as columns #inc_mat &lt;- table(edges_2mode[c(&#39;project_id&#39;, &#39;org_id&#39;)]) degree_norm_bip &lt;- bipartite::ND(as.matrix(net2)) # output has two measures of degree: one for &#39;lower&#39; and one for &#39;higher&#39; # &#39;lower&#39; is for for the rows, so in our case, projects length(degree_norm_bip$lower) == length(unique(edges_2mode$project_id)) ## [1] FALSE # this is compatible with mode 0, which are the second half of the nodes net2 %v% &#39;mode&#39; ## [1] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ## [38] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ## [75] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 ## [112] 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 0 0 0 0 0 0 0 0 0 ## [149] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [186] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [223] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [260] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [297] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [334] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [371] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ## [408] 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 # So we want to assign this bipartite degree in accordance with that order # BUT, note that this function orders degree based on numeric order of id, # which may not align with the node order nd_output &lt;- c(degree_norm_bip$higher, degree_norm_bip$lower) net2 %v% &#39;vertex.names&#39; == names(nd_output) ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [13] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [25] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [37] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [49] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [61] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [73] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [85] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [97] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [109] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [121] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [133] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [145] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [157] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [169] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [181] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [193] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [205] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [217] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [229] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [241] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [253] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [265] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [277] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [289] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [301] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [313] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [325] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [337] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [349] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [361] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [373] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [385] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [397] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [409] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [421] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [433] FALSE FALSE FALSE nd_output_df &lt;- data.frame(&#39;degreeN&#39; = nd_output, &#39;id&#39; = names(nd_output)) nd_output_sorted &lt;- nd_output_df[match((net2 %v% &#39;vertex.names&#39;), nd_output_df $id),] net2 %v% &#39;vertex.names&#39; == nd_output_sorted$id ## [1] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [16] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [31] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [46] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [61] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [76] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [91] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [106] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [121] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [136] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [151] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [166] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [181] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [196] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [211] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [226] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [241] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [256] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [271] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [286] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [301] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [316] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [331] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [346] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [361] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [376] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [391] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [406] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [421] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE net2 %v% &#39;degree_norm_bip&#39; &lt;- nd_output_sorted$degreeN # Note: normalizing the degree for the whole network vs. normalizing degree for # each mode is a different process (net2 %v% &#39;degree_norm&#39;)[net2 %v% &#39;vertex.names&#39; == 49590] ## [1] 0.0007352941 (net2 %v% &#39;degree_norm_bip&#39;)[net2 %v% &#39;vertex.names&#39; == 49590] ## [1] 0.003367003 topdeg_mode0 &lt;- data.frame(&quot;deg&quot; = (net2 %v% &#39;degree_norm_bip&#39;)[net2 %v% &#39;mode&#39; == 0]) %&gt;% top_n(3) topdeg_mode1 &lt;- data.frame(&quot;deg&quot; = (net2 %v% &#39;degree_norm_bip&#39;)[net2 %v% &#39;mode&#39; == 1]) %&gt;% top_n(3) net2 %v% &#39;labels_bip&#39; &lt;- ifelse((net2 %v% &#39;degree_norm_bip&#39;) %in% topdeg_mode0$deg &amp; net2 %v% &#39;mode&#39; == 0, net2 %v% &#39;name&#39;, ifelse((net2 %v% &#39;degree_norm_bip&#39;) %in% topdeg_mode1$deg &amp; net2 %v% &#39;mode&#39; == 1, net2 %v% &#39;name&#39;, &#39;&#39;)) ggraph(net2, layout = &#39;fr&#39;) + geom_edge_link(width = 0.5, alpha = 0.5, color = &quot;gray70&quot;) + geom_node_point(aes(size = net2 %v% &#39;degree_norm_bip&#39;, shape = factor(net2 %v% &#39;mode&#39;), color = factor(net2 %v% &#39;mode&#39;))) + theme_void() + scale_color_viridis_d() + geom_node_text(aes(label = net2 %v% &#39;labels_bip&#39;), size = 2, color=&quot;black&quot;) + labs(size = &quot;Degree&quot;, color = &quot;Mode&quot;, shape = &quot;Mode&quot;) But I want to demonstrate that there can be no connections between projects or between collaborators, in this network, so let’s pick a layout that demonstrates that Bipartite minimizes edge crossing net2 %v% &#39;type&#39; &lt;- ifelse(net2 %v% &#39;mode&#39; == 0, T, F) ggraph(net2, layout = &#39;bipartite&#39;) + geom_edge_link(width = 0.5, alpha = 0.5, color = &quot;gray70&quot;) + geom_node_point(aes(size = net2 %v% &#39;degree_norm_bip&#39;, shape = factor(net2 %v% &#39;mode&#39;), color = factor(net2 %v% &#39;mode&#39;)), alpha = .75) + theme_void() + scale_color_viridis_d() + geom_node_text(aes(label = net2 %v% &#39;labels_bip&#39;), size = 2, color=&quot;black&quot;) + labs(size = &quot;Degree&quot;, color = &quot;Mode&quot;, shape = &quot;Mode&quot;) Add a guide: I only want one legend ggraph(net2, layout = &#39;bipartite&#39;) + geom_edge_link(width = 0.5, alpha = 0.5, color = &quot;gray70&quot;) + geom_node_point(aes(size = net2 %v% &#39;degree_norm_bip&#39;, shape = factor(net2 %v% &#39;mode&#39;), color = factor(net2 %v% &#39;mode&#39;)), alpha = .75) + theme_void() + scale_color_viridis_d() + geom_node_text(aes(label = net2 %v% &#39;labels_bip&#39;), size = 2, color=&quot;black&quot;) + labs(color = &quot;Mode&quot;, shape = &quot;Mode&quot;) + guides(colour = &quot;legend&quot;, shape = &quot;legend&quot;, size = &quot;none&quot;) 6.2 Leaders versus contributors? We can return to the idea of subnetworks. 6.2.1 Induce subgraphs by edge # Induce subgraphs based on those edges net2_l &lt;- network::get.inducedSubgraph(net2, eid = which(net2 %e% &#39;leadership&#39; == T)) net2_c &lt;- network::get.inducedSubgraph(net2, eid = which(net2 %e% &#39;contribution&#39; == T)) Now we have subgraphs net2_l ## Network attributes: ## vertices = 368 ## directed = FALSE ## hyper = FALSE ## loops = FALSE ## multiple = FALSE ## bipartite = 71 ## total edges= 297 ## missing edges= 0 ## non-missing edges= 297 ## ## Vertex attribute names: ## degree degree_norm degree_norm_bip enddate funds labels labels_bip mgmt_Environmentalconditions mgmt_Floodriskandlandusemanagement mgmt_Governance mgmt_Habitatmanagement mgmt_Invasivenonnativespeciesmanagement mgmt_Nativespeciesmanagement mgmt_Waterquality mgmt_Watersupplymanagement mode n_years name sci_Amphibiansandreptiles sci_Aquaticvegetation sci_Biologicalresourceuse sci_Channelizedhabitats sci_Environmentalconditions sci_Fish sci_Floodplain sci_Foodwebs sci_Habitatchanges sci_Hydrologicchanges sci_Hydrologyandhydrodynamics sci_Invasivenonnativespecies sci_Invertebrates sci_Landuseandhumanactivities sci_Mammals sci_Nutrientsenergyandfoodweb sci_Riparianhabitats sci_Sediment sci_Species sci_Terrestrialhabitats sci_Tidalwetlands sci_Waterquality sci_Weatherandclimate startdate trunc_name type url vertex.names ## ## Edge attribute names: ## contribution leadership 6.3 Climate projects climate &lt;- which(net2 %v% &#39;sci_Weatherandclimate&#39; == T) landuse &lt;- which(net2 %v% &#39;sci_Landuseandhumanactivities&#39; == T) govnc &lt;- which(net2 %v% &#39;mgmt_Governance&#39; == T) flood &lt;- which(net2 %v% &#39;mgmt_Floodriskandlandusemanagement&#39; == T) # this is harder for bipartite net2_cli &lt;- network::get.inducedSubgraph(net2, v = climate) net2_cli ## Network attributes: ## vertices = 9 ## directed = FALSE ## hyper = FALSE ## loops = FALSE ## multiple = FALSE ## bipartite = 0 ## total edges= 0 ## missing edges= 0 ## non-missing edges= 0 ## ## Vertex attribute names: ## degree degree_norm degree_norm_bip enddate funds labels labels_bip mgmt_Environmentalconditions mgmt_Floodriskandlandusemanagement mgmt_Governance mgmt_Habitatmanagement mgmt_Invasivenonnativespeciesmanagement mgmt_Nativespeciesmanagement mgmt_Waterquality mgmt_Watersupplymanagement mode n_years name sci_Amphibiansandreptiles sci_Aquaticvegetation sci_Biologicalresourceuse sci_Channelizedhabitats sci_Environmentalconditions sci_Fish sci_Floodplain sci_Foodwebs sci_Habitatchanges sci_Hydrologicchanges sci_Hydrologyandhydrodynamics sci_Invasivenonnativespecies sci_Invertebrates sci_Landuseandhumanactivities sci_Mammals sci_Nutrientsenergyandfoodweb sci_Riparianhabitats sci_Sediment sci_Species sci_Terrestrialhabitats sci_Tidalwetlands sci_Waterquality sci_Weatherandclimate startdate trunc_name type url vertex.names ## ## No edge attributes climate_alter_ids &lt;- edges_2mode$org_id[edges_2mode$project_id %in% (net2 %v% &#39;vertex.names&#39;)[climate]] landuse_alter_ids &lt;- edges_2mode$org_id[edges_2mode$project_id %in% (net2 %v% &#39;vertex.names&#39;)[landuse]] govnc_alter_ids &lt;- edges_2mode$org_id[edges_2mode$project_id %in% (net2 %v% &#39;vertex.names&#39;)[govnc]] flood_alter_ids &lt;- edges_2mode$org_id[edges_2mode$project_id %in% (net2 %v% &#39;vertex.names&#39;)[flood]] climate_alters &lt;- which(net2 %v% &#39;vertex.names&#39; %in% climate_alter_ids) landuse_alters &lt;- which(net2 %v% &#39;vertex.names&#39; %in% landuse_alter_ids) govnc_alters &lt;- which(net2 %v% &#39;vertex.names&#39; %in% govnc_alter_ids) flood_alters &lt;- which(net2 %v% &#39;vertex.names&#39; %in% flood_alter_ids) net2_cli &lt;- network::get.inducedSubgraph(net2, v = climate, alters = climate_alters) net2_landuse &lt;- network::get.inducedSubgraph(net2, v = landuse, alters = landuse_alters) net2_govnc &lt;- network::get.inducedSubgraph(net2, v = govnc, alters = govnc_alters) net2_flood &lt;- network::get.inducedSubgraph(net2, v = flood, alters = flood_alters) assign_bipartite_deg_labels &lt;- function(netname, n){ degree_norm_bip &lt;- bipartite::ND(as.matrix(netname)) nd_output &lt;- c(degree_norm_bip$higher, degree_norm_bip$lower) nd_output_df &lt;- data.frame(&#39;degreeN&#39; = nd_output, &#39;id&#39; = names(nd_output)) nd_output_sorted &lt;- nd_output_df[match((netname %v% &#39;vertex.names&#39;), nd_output_df $id),] netname %v% &#39;degree_norm_bip&#39; &lt;- nd_output_sorted$degreeN topdeg_mode0 &lt;- data.frame(&quot;deg&quot; = (netname %v% &#39;degree_norm_bip&#39;)[netname %v% &#39;mode&#39; == 0]) %&gt;% top_n(n) topdeg_mode1 &lt;- data.frame(&quot;deg&quot; = (netname %v% &#39;degree_norm_bip&#39;)[netname %v% &#39;mode&#39; == 1]) %&gt;% top_n(n) netname %v% &#39;labels_org&#39; &lt;- ifelse((netname %v% &#39;degree_norm_bip&#39;) %in% topdeg_mode1$deg &amp; netname %v% &#39;mode&#39; == 1, netname %v% &#39;name&#39;, &#39;&#39;) return(netname) } net2_cli &lt;- assign_bipartite_deg_labels(net2_cli, 3) net2_landuse &lt;- assign_bipartite_deg_labels(net2_landuse, 3) net2_govnc &lt;- assign_bipartite_deg_labels(net2_govnc, 3) net2_flood &lt;- assign_bipartite_deg_labels(net2_flood, 3) plot_bipartite_fx &lt;- function(netname){ p &lt;- ggraph(netname, layout = &#39;bipartite&#39;) + geom_edge_link(width = 0.5, alpha = 0.5, color = &quot;gray70&quot;) + geom_node_point(aes(size = netname %v% &#39;degree_norm_bip&#39;, shape = factor(netname %v% &#39;mode&#39;), color = factor(netname %v% &#39;mode&#39;)), alpha = .75) + theme_void() + scale_color_viridis_d() + geom_node_text(aes(label = netname %v% &#39;labels_org&#39;), size = 2, color=&quot;black&quot;) + labs(color = &quot;Mode&quot;, shape = &quot;Mode&quot;) + guides(colour = &quot;legend&quot;, shape = &quot;legend&quot;, size = &quot;none&quot;) return(p) } plot_bipartite_fx(net2_cli) plot_bipartite_fx(net2_landuse) plot_bipartite_fx(net2_govnc) plot_bipartite_fx(net2_flood) "],["additional-resources.html", "7 Additional resources", " 7 Additional resources "],["igraph-visualiation.html", "8 igraph visualiation", " 8 igraph visualiation "],["ggnet2.html", "9 ggnet2", " 9 ggnet2 "],["interactive.html", "10 interactive", " 10 interactive "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
